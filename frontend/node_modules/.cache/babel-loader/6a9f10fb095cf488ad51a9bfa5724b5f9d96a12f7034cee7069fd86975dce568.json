{"ast":null,"code":"import { asciiAlphanumeric } from 'micromark-util-character';\nimport { encode } from 'micromark-util-encode';\nimport { codes, values } from 'micromark-util-symbol';\n\n/**\r\n * Make a value safe for injection as a URL.\r\n *\r\n * This encodes unsafe characters with percent-encoding and skips already\r\n * encoded sequences (see `normalizeUri`).\r\n * Further unsafe characters are encoded as character references (see\r\n * `micromark-util-encode`).\r\n *\r\n * A regex of allowed protocols can be given, in which case the URL is\r\n * sanitized.\r\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`, or\r\n * `/^https?$/i` for `img[src]` (this is what `github.com` allows).\r\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\r\n * as a dangerous example, `javascript:`), the value is ignored.\r\n *\r\n * @param {string | null | undefined} url\r\n *   URI to sanitize.\r\n * @param {RegExp | null | undefined} [protocol]\r\n *   Allowed protocols.\r\n * @returns {string}\r\n *   Sanitized URI.\r\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''));\n  if (!protocol) {\n    return value;\n  }\n  const colon = value.indexOf(':');\n  const questionMark = value.indexOf('?');\n  const numberSign = value.indexOf('#');\n  const slash = value.indexOf('/');\n  if (\n  // If there is no protocol, it’s relative.\n  colon < 0 ||\n  // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign ||\n  // It is a protocol, it should be allowed.\n  protocol.test(value.slice(0, colon))) {\n    return value;\n  }\n  return '';\n}\n\n/**\r\n * Normalize a URL.\r\n *\r\n * Encode unsafe characters with percent-encoding, skipping already encoded\r\n * sequences.\r\n *\r\n * @param {string} value\r\n *   URI to normalize.\r\n * @returns {string}\r\n *   Normalized URI.\r\n */\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = [];\n  let index = -1;\n  let start = 0;\n  let skip = 0;\n  while (++index < value.length) {\n    const code = value.charCodeAt(index);\n    /** @type {string} */\n    let replace = '';\n\n    // A correct percent encoded value.\n    if (code === codes.percentSign && asciiAlphanumeric(value.charCodeAt(index + 1)) && asciiAlphanumeric(value.charCodeAt(index + 2))) {\n      skip = 2;\n    }\n    // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code);\n      }\n    }\n    // Astral.\n    else if (code > 55_295 && code < 57_344) {\n      const next = value.charCodeAt(index + 1);\n\n      // A correct surrogate pair.\n      if (code < 56_320 && next > 56_319 && next < 57_344) {\n        replace = String.fromCharCode(code, next);\n        skip = 1;\n      }\n      // Lone surrogate.\n      else {\n        replace = values.replacementCharacter;\n      }\n    }\n    // Unicode.\n    else {\n      replace = String.fromCharCode(code);\n    }\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace));\n      start = index + skip + 1;\n      replace = '';\n    }\n    if (skip) {\n      index += skip;\n      skip = 0;\n    }\n  }\n  return result.join('') + value.slice(start);\n}","map":{"version":3,"names":["asciiAlphanumeric","encode","codes","values","sanitizeUri","url","protocol","value","normalizeUri","colon","indexOf","questionMark","numberSign","slash","test","slice","result","index","start","skip","length","code","charCodeAt","replace","percentSign","String","fromCharCode","next","replacementCharacter","push","encodeURIComponent","join"],"sources":["E:/Documents/2024-1 YBIGTA/React/blog_git/Ybigta-Blog/frontend/node_modules/micromark-util-sanitize-uri/dev/index.js"],"sourcesContent":["import {asciiAlphanumeric} from 'micromark-util-character'\r\nimport {encode} from 'micromark-util-encode'\r\nimport {codes, values} from 'micromark-util-symbol'\r\n\r\n/**\r\n * Make a value safe for injection as a URL.\r\n *\r\n * This encodes unsafe characters with percent-encoding and skips already\r\n * encoded sequences (see `normalizeUri`).\r\n * Further unsafe characters are encoded as character references (see\r\n * `micromark-util-encode`).\r\n *\r\n * A regex of allowed protocols can be given, in which case the URL is\r\n * sanitized.\r\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`, or\r\n * `/^https?$/i` for `img[src]` (this is what `github.com` allows).\r\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\r\n * as a dangerous example, `javascript:`), the value is ignored.\r\n *\r\n * @param {string | null | undefined} url\r\n *   URI to sanitize.\r\n * @param {RegExp | null | undefined} [protocol]\r\n *   Allowed protocols.\r\n * @returns {string}\r\n *   Sanitized URI.\r\n */\r\nexport function sanitizeUri(url, protocol) {\r\n  const value = encode(normalizeUri(url || ''))\r\n\r\n  if (!protocol) {\r\n    return value\r\n  }\r\n\r\n  const colon = value.indexOf(':')\r\n  const questionMark = value.indexOf('?')\r\n  const numberSign = value.indexOf('#')\r\n  const slash = value.indexOf('/')\r\n\r\n  if (\r\n    // If there is no protocol, it’s relative.\r\n    colon < 0 ||\r\n    // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\r\n    (slash > -1 && colon > slash) ||\r\n    (questionMark > -1 && colon > questionMark) ||\r\n    (numberSign > -1 && colon > numberSign) ||\r\n    // It is a protocol, it should be allowed.\r\n    protocol.test(value.slice(0, colon))\r\n  ) {\r\n    return value\r\n  }\r\n\r\n  return ''\r\n}\r\n\r\n/**\r\n * Normalize a URL.\r\n *\r\n * Encode unsafe characters with percent-encoding, skipping already encoded\r\n * sequences.\r\n *\r\n * @param {string} value\r\n *   URI to normalize.\r\n * @returns {string}\r\n *   Normalized URI.\r\n */\r\nexport function normalizeUri(value) {\r\n  /** @type {Array<string>} */\r\n  const result = []\r\n  let index = -1\r\n  let start = 0\r\n  let skip = 0\r\n\r\n  while (++index < value.length) {\r\n    const code = value.charCodeAt(index)\r\n    /** @type {string} */\r\n    let replace = ''\r\n\r\n    // A correct percent encoded value.\r\n    if (\r\n      code === codes.percentSign &&\r\n      asciiAlphanumeric(value.charCodeAt(index + 1)) &&\r\n      asciiAlphanumeric(value.charCodeAt(index + 2))\r\n    ) {\r\n      skip = 2\r\n    }\r\n    // ASCII.\r\n    else if (code < 128) {\r\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\r\n        replace = String.fromCharCode(code)\r\n      }\r\n    }\r\n    // Astral.\r\n    else if (code > 55_295 && code < 57_344) {\r\n      const next = value.charCodeAt(index + 1)\r\n\r\n      // A correct surrogate pair.\r\n      if (code < 56_320 && next > 56_319 && next < 57_344) {\r\n        replace = String.fromCharCode(code, next)\r\n        skip = 1\r\n      }\r\n      // Lone surrogate.\r\n      else {\r\n        replace = values.replacementCharacter\r\n      }\r\n    }\r\n    // Unicode.\r\n    else {\r\n      replace = String.fromCharCode(code)\r\n    }\r\n\r\n    if (replace) {\r\n      result.push(value.slice(start, index), encodeURIComponent(replace))\r\n      start = index + skip + 1\r\n      replace = ''\r\n    }\r\n\r\n    if (skip) {\r\n      index += skip\r\n      skip = 0\r\n    }\r\n  }\r\n\r\n  return result.join('') + value.slice(start)\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}