{"ast":null,"code":"/**\r\n * @typedef {import('../types.js').SafeConfig} SafeConfig\r\n * @typedef {import('../types.js').State} State\r\n */\n\nimport { patternInScope } from './pattern-in-scope.js';\n\n/**\r\n * Make a string safe for embedding in markdown constructs.\r\n *\r\n * In markdown, almost all punctuation characters can, in certain cases,\r\n * result in something.\r\n * Whether they do is highly subjective to where they happen and in what\r\n * they happen.\r\n *\r\n * To solve this, `mdast-util-to-markdown` tracks:\r\n *\r\n * * Characters before and after something;\r\n * * What “constructs” we are in.\r\n *\r\n * This information is then used by this function to escape or encode\r\n * special characters.\r\n *\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @param {string | null | undefined} input\r\n *   Raw value to make safe.\r\n * @param {SafeConfig} config\r\n *   Configuration.\r\n * @returns {string}\r\n *   Serialized markdown safe for embedding.\r\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '');\n  /** @type {Array<number>} */\n  const positions = [];\n  /** @type {Array<string>} */\n  const result = [];\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {};\n  let index = -1;\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index];\n    if (!patternInScope(state.stack, pattern)) {\n      continue;\n    }\n    const expression = state.compilePattern(pattern);\n    /** @type {RegExpExecArray | null} */\n    let match;\n    while (match = expression.exec(value)) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak);\n      const after = ('after' in pattern);\n      const position = match.index + (before ? match[1].length : 0);\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false;\n        }\n        if (infos[position].after && !after) {\n          infos[position].after = false;\n        }\n      } else {\n        positions.push(position);\n        infos[position] = {\n          before,\n          after\n        };\n      }\n    }\n  }\n  positions.sort(numerical);\n  let start = config.before ? config.before.length : 0;\n  const end = value.length - (config.after ? config.after.length : 0);\n  index = -1;\n  while (++index < positions.length) {\n    const position = positions[index];\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue;\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (position + 1 < end && positions[index + 1] === position + 1 && infos[position].after && !infos[position + 1].before && !infos[position + 1].after || positions[index - 1] === position - 1 && infos[position].before && !infos[position - 1].before && !infos[position - 1].after) {\n      continue;\n    }\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'));\n    }\n    start = position;\n    if (/[!-/:-@[-`{-~]/.test(value.charAt(position)) && (!config.encode || !config.encode.includes(value.charAt(position)))) {\n      // Character escape.\n      result.push('\\\\');\n    } else {\n      // Character reference.\n      result.push('&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';');\n      start++;\n    }\n  }\n  result.push(escapeBackslashes(value.slice(start, end), config.after));\n  return result.join('');\n}\n\n/**\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number}\r\n */\nfunction numerical(a, b) {\n  return a - b;\n}\n\n/**\r\n * @param {string} value\r\n * @param {string} after\r\n * @returns {string}\r\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g;\n  /** @type {Array<number>} */\n  const positions = [];\n  /** @type {Array<string>} */\n  const results = [];\n  const whole = value + after;\n  let index = -1;\n  let start = 0;\n  /** @type {RegExpExecArray | null} */\n  let match;\n  while (match = expression.exec(whole)) {\n    positions.push(match.index);\n  }\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]));\n    }\n    results.push('\\\\');\n    start = positions[index];\n  }\n  results.push(value.slice(start));\n  return results.join('');\n}","map":{"version":3,"names":["patternInScope","safe","state","input","config","value","before","after","positions","result","infos","index","unsafe","length","pattern","stack","expression","compilePattern","match","exec","Boolean","atBreak","position","includes","push","sort","numerical","start","end","escapeBackslashes","slice","test","charAt","encode","charCodeAt","toString","toUpperCase","join","a","b","results","whole"],"sources":["E:/Documents/2024-1 YBIGTA/Ybigta_BLOG/Ybigta-Blog/frontend/node_modules/mdast-util-to-markdown/lib/util/safe.js"],"sourcesContent":["/**\r\n * @typedef {import('../types.js').SafeConfig} SafeConfig\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\nimport {patternInScope} from './pattern-in-scope.js'\r\n\r\n/**\r\n * Make a string safe for embedding in markdown constructs.\r\n *\r\n * In markdown, almost all punctuation characters can, in certain cases,\r\n * result in something.\r\n * Whether they do is highly subjective to where they happen and in what\r\n * they happen.\r\n *\r\n * To solve this, `mdast-util-to-markdown` tracks:\r\n *\r\n * * Characters before and after something;\r\n * * What “constructs” we are in.\r\n *\r\n * This information is then used by this function to escape or encode\r\n * special characters.\r\n *\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @param {string | null | undefined} input\r\n *   Raw value to make safe.\r\n * @param {SafeConfig} config\r\n *   Configuration.\r\n * @returns {string}\r\n *   Serialized markdown safe for embedding.\r\n */\r\nexport function safe(state, input, config) {\r\n  const value = (config.before || '') + (input || '') + (config.after || '')\r\n  /** @type {Array<number>} */\r\n  const positions = []\r\n  /** @type {Array<string>} */\r\n  const result = []\r\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\r\n  const infos = {}\r\n  let index = -1\r\n\r\n  while (++index < state.unsafe.length) {\r\n    const pattern = state.unsafe[index]\r\n\r\n    if (!patternInScope(state.stack, pattern)) {\r\n      continue\r\n    }\r\n\r\n    const expression = state.compilePattern(pattern)\r\n    /** @type {RegExpExecArray | null} */\r\n    let match\r\n\r\n    while ((match = expression.exec(value))) {\r\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\r\n      const after = 'after' in pattern\r\n      const position = match.index + (before ? match[1].length : 0)\r\n\r\n      if (positions.includes(position)) {\r\n        if (infos[position].before && !before) {\r\n          infos[position].before = false\r\n        }\r\n\r\n        if (infos[position].after && !after) {\r\n          infos[position].after = false\r\n        }\r\n      } else {\r\n        positions.push(position)\r\n        infos[position] = {before, after}\r\n      }\r\n    }\r\n  }\r\n\r\n  positions.sort(numerical)\r\n\r\n  let start = config.before ? config.before.length : 0\r\n  const end = value.length - (config.after ? config.after.length : 0)\r\n  index = -1\r\n\r\n  while (++index < positions.length) {\r\n    const position = positions[index]\r\n\r\n    // Character before or after matched:\r\n    if (position < start || position >= end) {\r\n      continue\r\n    }\r\n\r\n    // If this character is supposed to be escaped because it has a condition on\r\n    // the next character, and the next character is definitly being escaped,\r\n    // then skip this escape.\r\n    if (\r\n      (position + 1 < end &&\r\n        positions[index + 1] === position + 1 &&\r\n        infos[position].after &&\r\n        !infos[position + 1].before &&\r\n        !infos[position + 1].after) ||\r\n      (positions[index - 1] === position - 1 &&\r\n        infos[position].before &&\r\n        !infos[position - 1].before &&\r\n        !infos[position - 1].after)\r\n    ) {\r\n      continue\r\n    }\r\n\r\n    if (start !== position) {\r\n      // If we have to use a character reference, an ampersand would be more\r\n      // correct, but as backslashes only care about punctuation, either will\r\n      // do the trick\r\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\r\n    }\r\n\r\n    start = position\r\n\r\n    if (\r\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\r\n      (!config.encode || !config.encode.includes(value.charAt(position)))\r\n    ) {\r\n      // Character escape.\r\n      result.push('\\\\')\r\n    } else {\r\n      // Character reference.\r\n      result.push(\r\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\r\n      )\r\n      start++\r\n    }\r\n  }\r\n\r\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\r\n\r\n  return result.join('')\r\n}\r\n\r\n/**\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number}\r\n */\r\nfunction numerical(a, b) {\r\n  return a - b\r\n}\r\n\r\n/**\r\n * @param {string} value\r\n * @param {string} after\r\n * @returns {string}\r\n */\r\nfunction escapeBackslashes(value, after) {\r\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\r\n  /** @type {Array<number>} */\r\n  const positions = []\r\n  /** @type {Array<string>} */\r\n  const results = []\r\n  const whole = value + after\r\n  let index = -1\r\n  let start = 0\r\n  /** @type {RegExpExecArray | null} */\r\n  let match\r\n\r\n  while ((match = expression.exec(whole))) {\r\n    positions.push(match.index)\r\n  }\r\n\r\n  while (++index < positions.length) {\r\n    if (start !== positions[index]) {\r\n      results.push(value.slice(start, positions[index]))\r\n    }\r\n\r\n    results.push('\\\\')\r\n    start = positions[index]\r\n  }\r\n\r\n  results.push(value.slice(start))\r\n\r\n  return results.join('')\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}