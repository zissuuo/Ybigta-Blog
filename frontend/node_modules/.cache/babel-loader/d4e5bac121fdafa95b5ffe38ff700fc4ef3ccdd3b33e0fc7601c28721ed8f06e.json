{"ast":null,"code":"/**\r\n * @typedef {import('mdast').Nodes} Nodes\r\n * @typedef {import('mdast').Parents} Parents\r\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\r\n * @typedef {import('mdast').Root} Root\r\n * @typedef {import('mdast').Text} Text\r\n * @typedef {import('unist-util-visit-parents').Test} Test\r\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\r\n */\n\n/**\r\n * @typedef RegExpMatchObject\r\n *   Info on the match.\r\n * @property {number} index\r\n *   The index of the search at which the result was found.\r\n * @property {string} input\r\n *   A copy of the search string in the text node.\r\n * @property {[...Array<Parents>, Text]} stack\r\n *   All ancestors of the text node, where the last node is the text itself.\r\n *\r\n * @typedef {RegExp | string} Find\r\n *   Pattern to find.\r\n *\r\n *   Strings are escaped and then turned into global expressions.\r\n *\r\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\r\n *   Several find and replaces, in array form.\r\n *\r\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\r\n *   Find and replace in tuple form.\r\n *\r\n * @typedef {ReplaceFunction | string | null | undefined} Replace\r\n *   Thing to replace with.\r\n *\r\n * @callback ReplaceFunction\r\n *   Callback called when a search matches.\r\n * @param {...any} parameters\r\n *   The parameters are the result of corresponding search expression:\r\n *\r\n *   * `value` (`string`) — whole match\r\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\r\n *   * `match` (`RegExpMatchObject`) — info on the match\r\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\r\n *   Thing to replace with.\r\n *\r\n *   * when `null`, `undefined`, `''`, remove the match\r\n *   * …or when `false`, do not replace at all\r\n *   * …or when `string`, replace with a text node of that value\r\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\r\n *\r\n * @typedef {[RegExp, ReplaceFunction]} Pair\r\n *   Normalized find and replace.\r\n *\r\n * @typedef {Array<Pair>} Pairs\r\n *   All find and replaced.\r\n *\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {Test | null | undefined} [ignore]\r\n *   Test for which nodes to ignore (optional).\r\n */\n\nimport escape from 'escape-string-regexp';\nimport { visitParents } from 'unist-util-visit-parents';\nimport { convert } from 'unist-util-is';\n\n/**\r\n * Find patterns in a tree and replace them.\r\n *\r\n * The algorithm searches the tree in *preorder* for complete values in `Text`\r\n * nodes.\r\n * Partial matches are not supported.\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to change.\r\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\r\n *   Patterns to find.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (when `find` is not `Find`).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {};\n  const ignored = convert(settings.ignore || []);\n  const pairs = toPairs(list);\n  let pairIndex = -1;\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor);\n  }\n\n  /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1;\n    /** @type {Parents | undefined} */\n    let grandparent;\n    while (++index < parents.length) {\n      const parent = parents[index];\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined;\n      if (ignored(parent, siblings ? siblings.indexOf(parent) : undefined, grandparent)) {\n        return;\n      }\n      grandparent = parent;\n    }\n    if (grandparent) {\n      return handler(node, parents);\n    }\n  }\n\n  /**\r\n   * Handle a text node which is not in an ignored parent.\r\n   *\r\n   * @param {Text} node\r\n   *   Text node.\r\n   * @param {Array<Parents>} parents\r\n   *   Parents.\r\n   * @returns {VisitorResult}\r\n   *   Result.\r\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1];\n    const find = pairs[pairIndex][0];\n    const replace = pairs[pairIndex][1];\n    let start = 0;\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children;\n    const index = siblings.indexOf(node);\n    let change = false;\n    /** @type {Array<PhrasingContent>} */\n    let nodes = [];\n    find.lastIndex = 0;\n    let match = find.exec(node.value);\n    while (match) {\n      const position = match.index;\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      };\n      let value = replace(...match, matchObject);\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {\n          type: 'text',\n          value\n        } : undefined;\n      }\n\n      // It wasn’t a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1;\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          });\n        }\n        if (Array.isArray(value)) {\n          nodes.push(...value);\n        } else if (value) {\n          nodes.push(value);\n        }\n        start = position + match[0].length;\n        change = true;\n      }\n      if (!find.global) {\n        break;\n      }\n      match = find.exec(node.value);\n    }\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({\n          type: 'text',\n          value: node.value.slice(start)\n        });\n      }\n      parent.children.splice(index, 1, ...nodes);\n    } else {\n      nodes = [node];\n    }\n    return index + nodes.length;\n  }\n}\n\n/**\r\n * Turn a tuple or a list of tuples into pairs.\r\n *\r\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\r\n *   Schema.\r\n * @returns {Pairs}\r\n *   Clean pairs.\r\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = [];\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples');\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];\n  let index = -1;\n  while (++index < list.length) {\n    const tuple = list[index];\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);\n  }\n  return result;\n}\n\n/**\r\n * Turn a find into an expression.\r\n *\r\n * @param {Find} find\r\n *   Find.\r\n * @returns {RegExp}\r\n *   Expression.\r\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find;\n}\n\n/**\r\n * Turn a replace into a function.\r\n *\r\n * @param {Replace} replace\r\n *   Replace.\r\n * @returns {ReplaceFunction}\r\n *   Function.\r\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : function () {\n    return replace;\n  };\n}","map":{"version":3,"names":["escape","visitParents","convert","findAndReplace","tree","list","options","settings","ignored","ignore","pairs","toPairs","pairIndex","length","visitor","node","parents","index","grandparent","parent","siblings","children","undefined","indexOf","handler","find","replace","start","change","nodes","lastIndex","match","exec","value","position","matchObject","input","stack","type","push","slice","Array","isArray","global","splice","tupleOrList","result","TypeError","tuple","toExpression","toFunction","RegExp"],"sources":["E:/Documents/2024-1 YBIGTA/React/blog_git/Ybigta-Blog/frontend/node_modules/mdast-util-find-and-replace/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('mdast').Nodes} Nodes\r\n * @typedef {import('mdast').Parents} Parents\r\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\r\n * @typedef {import('mdast').Root} Root\r\n * @typedef {import('mdast').Text} Text\r\n * @typedef {import('unist-util-visit-parents').Test} Test\r\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\r\n */\r\n\r\n/**\r\n * @typedef RegExpMatchObject\r\n *   Info on the match.\r\n * @property {number} index\r\n *   The index of the search at which the result was found.\r\n * @property {string} input\r\n *   A copy of the search string in the text node.\r\n * @property {[...Array<Parents>, Text]} stack\r\n *   All ancestors of the text node, where the last node is the text itself.\r\n *\r\n * @typedef {RegExp | string} Find\r\n *   Pattern to find.\r\n *\r\n *   Strings are escaped and then turned into global expressions.\r\n *\r\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\r\n *   Several find and replaces, in array form.\r\n *\r\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\r\n *   Find and replace in tuple form.\r\n *\r\n * @typedef {ReplaceFunction | string | null | undefined} Replace\r\n *   Thing to replace with.\r\n *\r\n * @callback ReplaceFunction\r\n *   Callback called when a search matches.\r\n * @param {...any} parameters\r\n *   The parameters are the result of corresponding search expression:\r\n *\r\n *   * `value` (`string`) — whole match\r\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\r\n *   * `match` (`RegExpMatchObject`) — info on the match\r\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\r\n *   Thing to replace with.\r\n *\r\n *   * when `null`, `undefined`, `''`, remove the match\r\n *   * …or when `false`, do not replace at all\r\n *   * …or when `string`, replace with a text node of that value\r\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\r\n *\r\n * @typedef {[RegExp, ReplaceFunction]} Pair\r\n *   Normalized find and replace.\r\n *\r\n * @typedef {Array<Pair>} Pairs\r\n *   All find and replaced.\r\n *\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {Test | null | undefined} [ignore]\r\n *   Test for which nodes to ignore (optional).\r\n */\r\n\r\nimport escape from 'escape-string-regexp'\r\nimport {visitParents} from 'unist-util-visit-parents'\r\nimport {convert} from 'unist-util-is'\r\n\r\n/**\r\n * Find patterns in a tree and replace them.\r\n *\r\n * The algorithm searches the tree in *preorder* for complete values in `Text`\r\n * nodes.\r\n * Partial matches are not supported.\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to change.\r\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\r\n *   Patterns to find.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (when `find` is not `Find`).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nexport function findAndReplace(tree, list, options) {\r\n  const settings = options || {}\r\n  const ignored = convert(settings.ignore || [])\r\n  const pairs = toPairs(list)\r\n  let pairIndex = -1\r\n\r\n  while (++pairIndex < pairs.length) {\r\n    visitParents(tree, 'text', visitor)\r\n  }\r\n\r\n  /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */\r\n  function visitor(node, parents) {\r\n    let index = -1\r\n    /** @type {Parents | undefined} */\r\n    let grandparent\r\n\r\n    while (++index < parents.length) {\r\n      const parent = parents[index]\r\n      /** @type {Array<Nodes> | undefined} */\r\n      const siblings = grandparent ? grandparent.children : undefined\r\n\r\n      if (\r\n        ignored(\r\n          parent,\r\n          siblings ? siblings.indexOf(parent) : undefined,\r\n          grandparent\r\n        )\r\n      ) {\r\n        return\r\n      }\r\n\r\n      grandparent = parent\r\n    }\r\n\r\n    if (grandparent) {\r\n      return handler(node, parents)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a text node which is not in an ignored parent.\r\n   *\r\n   * @param {Text} node\r\n   *   Text node.\r\n   * @param {Array<Parents>} parents\r\n   *   Parents.\r\n   * @returns {VisitorResult}\r\n   *   Result.\r\n   */\r\n  function handler(node, parents) {\r\n    const parent = parents[parents.length - 1]\r\n    const find = pairs[pairIndex][0]\r\n    const replace = pairs[pairIndex][1]\r\n    let start = 0\r\n    /** @type {Array<Nodes>} */\r\n    const siblings = parent.children\r\n    const index = siblings.indexOf(node)\r\n    let change = false\r\n    /** @type {Array<PhrasingContent>} */\r\n    let nodes = []\r\n\r\n    find.lastIndex = 0\r\n\r\n    let match = find.exec(node.value)\r\n\r\n    while (match) {\r\n      const position = match.index\r\n      /** @type {RegExpMatchObject} */\r\n      const matchObject = {\r\n        index: match.index,\r\n        input: match.input,\r\n        stack: [...parents, node]\r\n      }\r\n      let value = replace(...match, matchObject)\r\n\r\n      if (typeof value === 'string') {\r\n        value = value.length > 0 ? {type: 'text', value} : undefined\r\n      }\r\n\r\n      // It wasn’t a match after all.\r\n      if (value === false) {\r\n        // False acts as if there was no match.\r\n        // So we need to reset `lastIndex`, which currently being at the end of\r\n        // the current match, to the beginning.\r\n        find.lastIndex = position + 1\r\n      } else {\r\n        if (start !== position) {\r\n          nodes.push({\r\n            type: 'text',\r\n            value: node.value.slice(start, position)\r\n          })\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n          nodes.push(...value)\r\n        } else if (value) {\r\n          nodes.push(value)\r\n        }\r\n\r\n        start = position + match[0].length\r\n        change = true\r\n      }\r\n\r\n      if (!find.global) {\r\n        break\r\n      }\r\n\r\n      match = find.exec(node.value)\r\n    }\r\n\r\n    if (change) {\r\n      if (start < node.value.length) {\r\n        nodes.push({type: 'text', value: node.value.slice(start)})\r\n      }\r\n\r\n      parent.children.splice(index, 1, ...nodes)\r\n    } else {\r\n      nodes = [node]\r\n    }\r\n\r\n    return index + nodes.length\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a tuple or a list of tuples into pairs.\r\n *\r\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\r\n *   Schema.\r\n * @returns {Pairs}\r\n *   Clean pairs.\r\n */\r\nfunction toPairs(tupleOrList) {\r\n  /** @type {Pairs} */\r\n  const result = []\r\n\r\n  if (!Array.isArray(tupleOrList)) {\r\n    throw new TypeError('Expected find and replace tuple or list of tuples')\r\n  }\r\n\r\n  /** @type {FindAndReplaceList} */\r\n  // @ts-expect-error: correct.\r\n  const list =\r\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\r\n      ? tupleOrList\r\n      : [tupleOrList]\r\n\r\n  let index = -1\r\n\r\n  while (++index < list.length) {\r\n    const tuple = list[index]\r\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Turn a find into an expression.\r\n *\r\n * @param {Find} find\r\n *   Find.\r\n * @returns {RegExp}\r\n *   Expression.\r\n */\r\nfunction toExpression(find) {\r\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\r\n}\r\n\r\n/**\r\n * Turn a replace into a function.\r\n *\r\n * @param {Replace} replace\r\n *   Replace.\r\n * @returns {ReplaceFunction}\r\n *   Function.\r\n */\r\nfunction toFunction(replace) {\r\n  return typeof replace === 'function'\r\n    ? replace\r\n    : function () {\r\n        return replace\r\n      }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}