{"ast":null,"code":"/**\r\n * @typedef {import('mdast').Nodes} Nodes\r\n * @typedef {import('./types.js').Enter} Enter\r\n * @typedef {import('./types.js').Info} Info\r\n * @typedef {import('./types.js').Join} Join\r\n * @typedef {import('./types.js').FlowParents} FlowParents\r\n * @typedef {import('./types.js').Options} Options\r\n * @typedef {import('./types.js').PhrasingParents} PhrasingParents\r\n * @typedef {import('./types.js').SafeConfig} SafeConfig\r\n * @typedef {import('./types.js').State} State\r\n * @typedef {import('./types.js').TrackFields} TrackFields\r\n */\n\nimport { zwitch } from 'zwitch';\nimport { configure } from './configure.js';\nimport { handle as handlers } from './handle/index.js';\nimport { join } from './join.js';\nimport { unsafe } from './unsafe.js';\nimport { association } from './util/association.js';\nimport { compilePattern } from './util/compile-pattern.js';\nimport { containerPhrasing } from './util/container-phrasing.js';\nimport { containerFlow } from './util/container-flow.js';\nimport { indentLines } from './util/indent-lines.js';\nimport { safe } from './util/safe.js';\nimport { track } from './util/track.js';\n\n/**\r\n * Turn an mdast syntax tree into markdown.\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to serialize.\r\n * @param {Options} [options]\r\n *   Configuration (optional).\r\n * @returns {string}\r\n *   Serialized markdown representing `tree`.\r\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {State} */\n  const state = {\n    enter,\n    indentLines,\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    compilePattern,\n    safe: safeBound,\n    stack: [],\n    unsafe: [...unsafe],\n    join: [...join],\n    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined\n    // here.\n    handlers: {\n      ...handlers\n    },\n    options: {},\n    indexStack: [],\n    // @ts-expect-error: add `handle` in a second.\n    handle: undefined\n  };\n  configure(state, options);\n  if (state.options.tightDefinitions) {\n    state.join.push(joinDefinition);\n  }\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  });\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {\n      line: 1,\n      column: 1\n    },\n    lineShift: 0\n  });\n  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {\n    result += '\\n';\n  }\n  return result;\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name);\n    return exit;\n\n    /**\r\n     * @returns {undefined}\r\n     */\n    function exit() {\n      state.stack.pop();\n    }\n  }\n}\n\n/**\r\n * @param {unknown} value\r\n * @returns {never}\r\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node');\n}\n\n/**\r\n * @param {unknown} value\r\n * @returns {never}\r\n */\nfunction unknown(value) {\n  // Always a node.\n  const node = /** @type {Nodes} */value;\n  throw new Error('Cannot handle unknown node `' + node.type + '`');\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0;\n  }\n}\n\n/**\r\n * Serialize the children of a parent that contains phrasing children.\r\n *\r\n * These children will be joined flush together.\r\n *\r\n * @this {State}\r\n *   Info passed around about the current state.\r\n * @param {PhrasingParents} parent\r\n *   Parent of flow nodes.\r\n * @param {Info} info\r\n *   Info on where we are in the document we are generating.\r\n * @returns {string}\r\n *   Serialized children, joined together.\r\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info);\n}\n\n/**\r\n * Serialize the children of a parent that contains flow children.\r\n *\r\n * These children will typically be joined by blank lines.\r\n * What they are joined by exactly is defined by `Join` functions.\r\n *\r\n * @this {State}\r\n *   Info passed around about the current state.\r\n * @param {FlowParents} parent\r\n *   Parent of flow nodes.\r\n * @param {TrackFields} info\r\n *   Info on where we are in the document we are generating.\r\n * @returns {string}\r\n *   Serialized children, joined by (blank) lines.\r\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info);\n}\n\n/**\r\n * Make a string safe for embedding in markdown constructs.\r\n *\r\n * In markdown, almost all punctuation characters can, in certain cases,\r\n * result in something.\r\n * Whether they do is highly subjective to where they happen and in what\r\n * they happen.\r\n *\r\n * To solve this, `mdast-util-to-markdown` tracks:\r\n *\r\n * * Characters before and after something;\r\n * * What “constructs” we are in.\r\n *\r\n * This information is then used by this function to escape or encode\r\n * special characters.\r\n *\r\n * @this {State}\r\n *   Info passed around about the current state.\r\n * @param {string | null | undefined} value\r\n *   Raw value to make safe.\r\n * @param {SafeConfig} config\r\n *   Configuration.\r\n * @returns {string}\r\n *   Serialized markdown safe for embedding.\r\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config);\n}","map":{"version":3,"names":["zwitch","configure","handle","handlers","join","unsafe","association","compilePattern","containerPhrasing","containerFlow","indentLines","safe","track","toMarkdown","tree","options","state","enter","associationId","containerPhrasingBound","containerFlowBound","createTracker","safeBound","stack","indexStack","undefined","tightDefinitions","push","joinDefinition","invalid","unknown","result","before","after","now","line","column","lineShift","charCodeAt","length","name","exit","pop","value","Error","node","type","left","right","parent","info","config"],"sources":["E:/Documents/2024-1 YBIGTA/Ybigta_BLOG/Ybigta-Blog/frontend/node_modules/mdast-util-to-markdown/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('mdast').Nodes} Nodes\r\n * @typedef {import('./types.js').Enter} Enter\r\n * @typedef {import('./types.js').Info} Info\r\n * @typedef {import('./types.js').Join} Join\r\n * @typedef {import('./types.js').FlowParents} FlowParents\r\n * @typedef {import('./types.js').Options} Options\r\n * @typedef {import('./types.js').PhrasingParents} PhrasingParents\r\n * @typedef {import('./types.js').SafeConfig} SafeConfig\r\n * @typedef {import('./types.js').State} State\r\n * @typedef {import('./types.js').TrackFields} TrackFields\r\n */\r\n\r\nimport {zwitch} from 'zwitch'\r\nimport {configure} from './configure.js'\r\nimport {handle as handlers} from './handle/index.js'\r\nimport {join} from './join.js'\r\nimport {unsafe} from './unsafe.js'\r\nimport {association} from './util/association.js'\r\nimport {compilePattern} from './util/compile-pattern.js'\r\nimport {containerPhrasing} from './util/container-phrasing.js'\r\nimport {containerFlow} from './util/container-flow.js'\r\nimport {indentLines} from './util/indent-lines.js'\r\nimport {safe} from './util/safe.js'\r\nimport {track} from './util/track.js'\r\n\r\n/**\r\n * Turn an mdast syntax tree into markdown.\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to serialize.\r\n * @param {Options} [options]\r\n *   Configuration (optional).\r\n * @returns {string}\r\n *   Serialized markdown representing `tree`.\r\n */\r\nexport function toMarkdown(tree, options = {}) {\r\n  /** @type {State} */\r\n  const state = {\r\n    enter,\r\n    indentLines,\r\n    associationId: association,\r\n    containerPhrasing: containerPhrasingBound,\r\n    containerFlow: containerFlowBound,\r\n    createTracker: track,\r\n    compilePattern,\r\n    safe: safeBound,\r\n    stack: [],\r\n    unsafe: [...unsafe],\r\n    join: [...join],\r\n    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined\r\n    // here.\r\n    handlers: {...handlers},\r\n    options: {},\r\n    indexStack: [],\r\n    // @ts-expect-error: add `handle` in a second.\r\n    handle: undefined\r\n  }\r\n\r\n  configure(state, options)\r\n\r\n  if (state.options.tightDefinitions) {\r\n    state.join.push(joinDefinition)\r\n  }\r\n\r\n  state.handle = zwitch('type', {\r\n    invalid,\r\n    unknown,\r\n    handlers: state.handlers\r\n  })\r\n\r\n  let result = state.handle(tree, undefined, state, {\r\n    before: '\\n',\r\n    after: '\\n',\r\n    now: {line: 1, column: 1},\r\n    lineShift: 0\r\n  })\r\n\r\n  if (\r\n    result &&\r\n    result.charCodeAt(result.length - 1) !== 10 &&\r\n    result.charCodeAt(result.length - 1) !== 13\r\n  ) {\r\n    result += '\\n'\r\n  }\r\n\r\n  return result\r\n\r\n  /** @type {Enter} */\r\n  function enter(name) {\r\n    state.stack.push(name)\r\n    return exit\r\n\r\n    /**\r\n     * @returns {undefined}\r\n     */\r\n    function exit() {\r\n      state.stack.pop()\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {unknown} value\r\n * @returns {never}\r\n */\r\nfunction invalid(value) {\r\n  throw new Error('Cannot handle value `' + value + '`, expected node')\r\n}\r\n\r\n/**\r\n * @param {unknown} value\r\n * @returns {never}\r\n */\r\nfunction unknown(value) {\r\n  // Always a node.\r\n  const node = /** @type {Nodes} */ (value)\r\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\r\n}\r\n\r\n/** @type {Join} */\r\nfunction joinDefinition(left, right) {\r\n  // No blank line between adjacent definitions.\r\n  if (left.type === 'definition' && left.type === right.type) {\r\n    return 0\r\n  }\r\n}\r\n\r\n/**\r\n * Serialize the children of a parent that contains phrasing children.\r\n *\r\n * These children will be joined flush together.\r\n *\r\n * @this {State}\r\n *   Info passed around about the current state.\r\n * @param {PhrasingParents} parent\r\n *   Parent of flow nodes.\r\n * @param {Info} info\r\n *   Info on where we are in the document we are generating.\r\n * @returns {string}\r\n *   Serialized children, joined together.\r\n */\r\nfunction containerPhrasingBound(parent, info) {\r\n  return containerPhrasing(parent, this, info)\r\n}\r\n\r\n/**\r\n * Serialize the children of a parent that contains flow children.\r\n *\r\n * These children will typically be joined by blank lines.\r\n * What they are joined by exactly is defined by `Join` functions.\r\n *\r\n * @this {State}\r\n *   Info passed around about the current state.\r\n * @param {FlowParents} parent\r\n *   Parent of flow nodes.\r\n * @param {TrackFields} info\r\n *   Info on where we are in the document we are generating.\r\n * @returns {string}\r\n *   Serialized children, joined by (blank) lines.\r\n */\r\nfunction containerFlowBound(parent, info) {\r\n  return containerFlow(parent, this, info)\r\n}\r\n\r\n/**\r\n * Make a string safe for embedding in markdown constructs.\r\n *\r\n * In markdown, almost all punctuation characters can, in certain cases,\r\n * result in something.\r\n * Whether they do is highly subjective to where they happen and in what\r\n * they happen.\r\n *\r\n * To solve this, `mdast-util-to-markdown` tracks:\r\n *\r\n * * Characters before and after something;\r\n * * What “constructs” we are in.\r\n *\r\n * This information is then used by this function to escape or encode\r\n * special characters.\r\n *\r\n * @this {State}\r\n *   Info passed around about the current state.\r\n * @param {string | null | undefined} value\r\n *   Raw value to make safe.\r\n * @param {SafeConfig} config\r\n *   Configuration.\r\n * @returns {string}\r\n *   Serialized markdown safe for embedding.\r\n */\r\nfunction safeBound(value, config) {\r\n  return safe(this, value, config)\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}