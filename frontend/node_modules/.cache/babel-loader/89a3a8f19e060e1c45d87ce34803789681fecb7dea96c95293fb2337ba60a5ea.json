{"ast":null,"code":"/**\r\n * @typedef {import('mdast').InlineCode} InlineCode\r\n * @typedef {import('mdast').Parents} Parents\r\n * @typedef {import('../types.js').State} State\r\n */\n\ninlineCode.peek = inlineCodePeek;\n\n/**\r\n * @param {InlineCode} node\r\n * @param {Parents | undefined} _\r\n * @param {State} state\r\n * @returns {string}\r\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || '';\n  let sequence = '`';\n  let index = -1;\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`';\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (/[^ \\r\\n]/.test(value) && (/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) || /^`|`$/.test(value))) {\n    value = ' ' + value + ' ';\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index];\n    const expression = state.compilePattern(pattern);\n    /** @type {RegExpExecArray | null} */\n    let match;\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue;\n    while (match = expression.exec(value)) {\n      let position = match.index;\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (value.charCodeAt(position) === 10 /* `\\n` */ && value.charCodeAt(position - 1) === 13 /* `\\r` */) {\n        position--;\n      }\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\n    }\n  }\n  return sequence + value + sequence;\n}\n\n/**\r\n * @returns {string}\r\n */\nfunction inlineCodePeek() {\n  return '`';\n}","map":{"version":3,"names":["inlineCode","peek","inlineCodePeek","node","_","state","value","sequence","index","RegExp","test","unsafe","length","pattern","expression","compilePattern","match","atBreak","exec","position","charCodeAt","slice"],"sources":["E:/Documents/2024-1 YBIGTA/Ybigta_BLOG/blog_git/Ybigta-Blog/frontend/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js"],"sourcesContent":["/**\r\n * @typedef {import('mdast').InlineCode} InlineCode\r\n * @typedef {import('mdast').Parents} Parents\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\ninlineCode.peek = inlineCodePeek\r\n\r\n/**\r\n * @param {InlineCode} node\r\n * @param {Parents | undefined} _\r\n * @param {State} state\r\n * @returns {string}\r\n */\r\nexport function inlineCode(node, _, state) {\r\n  let value = node.value || ''\r\n  let sequence = '`'\r\n  let index = -1\r\n\r\n  // If there is a single grave accent on its own in the code, use a fence of\r\n  // two.\r\n  // If there are two in a row, use one.\r\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\r\n    sequence += '`'\r\n  }\r\n\r\n  // If this is not just spaces or eols (tabs don’t count), and either the\r\n  // first or last character are a space, eol, or tick, then pad with spaces.\r\n  if (\r\n    /[^ \\r\\n]/.test(value) &&\r\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\r\n  ) {\r\n    value = ' ' + value + ' '\r\n  }\r\n\r\n  // We have a potential problem: certain characters after eols could result in\r\n  // blocks being seen.\r\n  // For example, if someone injected the string `'\\n# b'`, then that would\r\n  // result in an ATX heading.\r\n  // We can’t escape characters in `inlineCode`, but because eols are\r\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\r\n  // them out.\r\n  while (++index < state.unsafe.length) {\r\n    const pattern = state.unsafe[index]\r\n    const expression = state.compilePattern(pattern)\r\n    /** @type {RegExpExecArray | null} */\r\n    let match\r\n\r\n    // Only look for `atBreak`s.\r\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\r\n    // CR.\r\n    if (!pattern.atBreak) continue\r\n\r\n    while ((match = expression.exec(value))) {\r\n      let position = match.index\r\n\r\n      // Support CRLF (patterns only look for one of the characters).\r\n      if (\r\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\r\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\r\n      ) {\r\n        position--\r\n      }\r\n\r\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\r\n    }\r\n  }\r\n\r\n  return sequence + value + sequence\r\n}\r\n\r\n/**\r\n * @returns {string}\r\n */\r\nfunction inlineCodePeek() {\r\n  return '`'\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEAA,UAAU,CAACC,IAAI,GAAGC,cAAc;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASF,UAAUA,CAACG,IAAI,EAAEC,CAAC,EAAEC,KAAK,EAAE;EACzC,IAAIC,KAAK,GAAGH,IAAI,CAACG,KAAK,IAAI,EAAE;EAC5B,IAAIC,QAAQ,GAAG,GAAG;EAClB,IAAIC,KAAK,GAAG,CAAC,CAAC;;EAEd;EACA;EACA;EACA,OAAO,IAAIC,MAAM,CAAC,UAAU,GAAGF,QAAQ,GAAG,UAAU,CAAC,CAACG,IAAI,CAACJ,KAAK,CAAC,EAAE;IACjEC,QAAQ,IAAI,GAAG;EACjB;;EAEA;EACA;EACA,IACE,UAAU,CAACG,IAAI,CAACJ,KAAK,CAAC,KACpB,UAAU,CAACI,IAAI,CAACJ,KAAK,CAAC,IAAI,UAAU,CAACI,IAAI,CAACJ,KAAK,CAAC,IAAK,OAAO,CAACI,IAAI,CAACJ,KAAK,CAAC,CAAC,EAC3E;IACAA,KAAK,GAAG,GAAG,GAAGA,KAAK,GAAG,GAAG;EAC3B;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,OAAO,EAAEE,KAAK,GAAGH,KAAK,CAACM,MAAM,CAACC,MAAM,EAAE;IACpC,MAAMC,OAAO,GAAGR,KAAK,CAACM,MAAM,CAACH,KAAK,CAAC;IACnC,MAAMM,UAAU,GAAGT,KAAK,CAACU,cAAc,CAACF,OAAO,CAAC;IAChD;IACA,IAAIG,KAAK;;IAET;IACA;IACA;IACA,IAAI,CAACH,OAAO,CAACI,OAAO,EAAE;IAEtB,OAAQD,KAAK,GAAGF,UAAU,CAACI,IAAI,CAACZ,KAAK,CAAC,EAAG;MACvC,IAAIa,QAAQ,GAAGH,KAAK,CAACR,KAAK;;MAE1B;MACA,IACEF,KAAK,CAACc,UAAU,CAACD,QAAQ,CAAC,KAAK,EAAE,CAAC,cAClCb,KAAK,CAACc,UAAU,CAACD,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,YACtC;QACAA,QAAQ,EAAE;MACZ;MAEAb,KAAK,GAAGA,KAAK,CAACe,KAAK,CAAC,CAAC,EAAEF,QAAQ,CAAC,GAAG,GAAG,GAAGb,KAAK,CAACe,KAAK,CAACL,KAAK,CAACR,KAAK,GAAG,CAAC,CAAC;IACvE;EACF;EAEA,OAAOD,QAAQ,GAAGD,KAAK,GAAGC,QAAQ;AACpC;;AAEA;AACA;AACA;AACA,SAASL,cAAcA,CAAA,EAAG;EACxB,OAAO,GAAG;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}