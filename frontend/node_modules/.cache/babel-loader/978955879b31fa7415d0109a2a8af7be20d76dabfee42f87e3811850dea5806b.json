{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').Code} Code\r\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\r\n * @typedef {import('micromark-util-types').Event} Event\r\n * @typedef {import('micromark-util-types').Extension} Extension\r\n * @typedef {import('micromark-util-types').Previous} Previous\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n */\n\nimport { asciiAlpha, asciiAlphanumeric, asciiControl, markdownLineEndingOrSpace, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol';\nconst wwwPrefix = {\n  tokenize: tokenizeWwwPrefix,\n  partial: true\n};\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n};\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n};\nconst trail = {\n  tokenize: tokenizeTrail,\n  partial: true\n};\nconst emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n};\nconst wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nconst protocolAutolink = {\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n};\nconst emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\n\n/** @type {ConstructRecord} */\nconst text = {};\n\n/**\r\n * Create an extension for `micromark` to support GitHub autolink literal\r\n * syntax.\r\n *\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\r\n *   autolink literal syntax.\r\n */\nexport function gfmAutolinkLiteral() {\n  return {\n    text\n  };\n}\n\n/** @type {Code} */\nlet code = codes.digit0;\n\n// Add alphanumerics.\nwhile (code < codes.leftCurlyBrace) {\n  text[code] = emailAutolink;\n  code++;\n  if (code === codes.colon) code = codes.uppercaseA;else if (code === codes.leftSquareBracket) code = codes.lowercaseA;\n}\ntext[codes.plusSign] = emailAutolink;\ntext[codes.dash] = emailAutolink;\ntext[codes.dot] = emailAutolink;\ntext[codes.underscore] = emailAutolink;\ntext[codes.uppercaseH] = [emailAutolink, protocolAutolink];\ntext[codes.lowercaseH] = [emailAutolink, protocolAutolink];\ntext[codes.uppercaseW] = [emailAutolink, wwwAutolink];\ntext[codes.lowercaseW] = [emailAutolink, wwwAutolink];\n\n// To do: perform email autolink literals on events, afterwards.\n// That’s where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\r\n * Email autolink literal.\r\n *\r\n * ```markdown\r\n * > | a contact@example.org b\r\n *       ^^^^^^^^^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this;\n  /** @type {boolean | undefined} */\n  let dot;\n  /** @type {boolean} */\n  let data;\n  return start;\n\n  /**\r\n   * Start of email autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function start(code) {\n    if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkEmail');\n    return atext(code);\n  }\n\n  /**\r\n   * In email atext.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code);\n      return atext;\n    }\n    if (code === codes.atSign) {\n      effects.consume(code);\n      return emailDomain;\n    }\n    return nok(code);\n  }\n\n  /**\r\n   * In email domain.\r\n   *\r\n   * The reference code is a bit overly complex as it handles the `@`, of which\r\n   * there may be just one.\r\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *               ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === codes.dot) {\n      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);\n    }\n\n    // Alphanumerical, `-`, and `_`.\n    if (code === codes.dash || code === codes.underscore || asciiAlphanumeric(code)) {\n      data = true;\n      effects.consume(code);\n      return emailDomain;\n    }\n\n    // To do: `/` if xmpp.\n\n    // Note: normally we’d truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isn’t trailing.\n    // So we can ignore truncating!\n    return emailDomainAfter(code);\n  }\n\n  /**\r\n   * In email domain, on dot that is not a trail.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *                      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function emailDomainDot(code) {\n    effects.consume(code);\n    dot = true;\n    return emailDomain;\n  }\n\n  /**\r\n   * After email domain.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *                          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit('literalAutolinkEmail');\n      effects.exit('literalAutolink');\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n\n/**\r\n * `www` autolink literal.\r\n *\r\n * ```markdown\r\n * > | a www.example.org b\r\n *       ^^^^^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this;\n  return wwwStart;\n\n  /**\r\n   * Start of www autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com/a?b#c\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function wwwStart(code) {\n    if (code !== codes.uppercaseW && code !== codes.lowercaseW || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkWww');\n    // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);\n  }\n\n  /**\r\n   * After a www autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com/a?b#c\r\n   *                          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\r\n * Protocol autolink literal.\r\n *\r\n * ```markdown\r\n * > | a https://example.org b\r\n *       ^^^^^^^^^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  const self = this;\n  let buffer = '';\n  let seen = false;\n  return protocolStart;\n\n  /**\r\n   * Start of protocol autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function protocolStart(code) {\n    if ((code === codes.uppercaseH || code === codes.lowercaseH) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {\n      effects.enter('literalAutolink');\n      effects.enter('literalAutolinkHttp');\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    return nok(code);\n  }\n\n  /**\r\n   * In protocol.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *     ^^^^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if (asciiAlpha(code) && buffer.length < 5) {\n      // @ts-expect-error: definitely number.\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    if (code === codes.colon) {\n      const protocol = buffer.toLowerCase();\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code);\n        return protocolSlashesInside;\n      }\n    }\n    return nok(code);\n  }\n\n  /**\r\n   * In slashes.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *           ^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function protocolSlashesInside(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      if (seen) {\n        return afterProtocol;\n      }\n      seen = true;\n      return protocolSlashesInside;\n    }\n    return nok(code);\n  }\n\n  /**\r\n   * After protocol, before domain.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *             ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === codes.eof || asciiControl(code) || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);\n  }\n\n  /**\r\n   * After a protocol autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *                              ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\r\n * `www` prefix.\r\n *\r\n * ```markdown\r\n * > | a www.example.org b\r\n *       ^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  let size = 0;\n  return wwwPrefixInside;\n\n  /**\r\n   * In www prefix.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com\r\n   *     ^^^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function wwwPrefixInside(code) {\n    if ((code === codes.uppercaseW || code === codes.lowercaseW) && size < 3) {\n      size++;\n      effects.consume(code);\n      return wwwPrefixInside;\n    }\n    if (code === codes.dot && size === 3) {\n      effects.consume(code);\n      return wwwPrefixAfter;\n    }\n    return nok(code);\n  }\n\n  /**\r\n   * After www prefix.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === codes.eof ? nok(code) : ok(code);\n  }\n}\n\n/**\r\n * Domain.\r\n *\r\n * ```markdown\r\n * > | a https://example.org b\r\n *               ^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  let underscoreInLastSegment;\n  /** @type {boolean | undefined} */\n  let underscoreInLastLastSegment;\n  /** @type {boolean | undefined} */\n  let seen;\n  return domainInside;\n\n  /**\r\n   * In domain.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\r\n   *             ^^^^^^^^^^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === codes.dot || code === codes.underscore) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code);\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n    if (code === codes.eof || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || code !== codes.dash && unicodePunctuation(code)) {\n      return domainAfter(code);\n    }\n    seen = true;\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\r\n   * In domain, at potential trailing punctuation, that was not trailing.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com\r\n   *                    ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === codes.underscore) {\n      underscoreInLastSegment = true;\n    }\n    // Otherwise, it’s a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment;\n      underscoreInLastSegment = undefined;\n    }\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\r\n   * After domain.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\r\n   *                        ^\r\n   * ```\r\n   *\r\n   * @type {State} */\n  function domainAfter(code) {\n    // Note: that’s GH says a dot is needed, but it’s not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code);\n    }\n    return ok(code);\n  }\n}\n\n/**\r\n * Path.\r\n *\r\n * ```markdown\r\n * > | a https://example.org/stuff b\r\n *                          ^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizePath(effects, ok) {\n  let sizeOpen = 0;\n  let sizeClose = 0;\n  return pathInside;\n\n  /**\r\n   * In path.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\r\n   *                        ^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function pathInside(code) {\n    if (code === codes.leftParenthesis) {\n      sizeOpen++;\n      effects.consume(code);\n      return pathInside;\n    }\n\n    // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we don’t check for a trail.\n    if (code === codes.rightParenthesis && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code);\n    }\n\n    // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n    if (code === codes.exclamationMark || code === codes.quotationMark || code === codes.ampersand || code === codes.apostrophe || code === codes.rightParenthesis || code === codes.asterisk || code === codes.comma || code === codes.dot || code === codes.colon || code === codes.semicolon || code === codes.lessThan || code === codes.questionMark || code === codes.rightSquareBracket || code === codes.underscore || code === codes.tilde) {\n      return effects.check(trail, ok, pathAtPunctuation)(code);\n    }\n    if (code === codes.eof || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n\n  /**\r\n   * In path, at potential trailing punctuation, that was not trailing.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\"b\r\n   *                          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === codes.rightParenthesis) {\n      sizeClose++;\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n}\n\n/**\r\n * Trail.\r\n *\r\n * This calls `ok` if this *is* the trail, followed by an end, which means\r\n * the entire trail is not part of the link.\r\n * It calls `nok` if this *is* part of the link.\r\n *\r\n * ```markdown\r\n * > | https://example.com\").\r\n *                        ^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail;\n\n  /**\r\n   * In trail of domain or path.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com\").\r\n   *                        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (code === codes.exclamationMark || code === codes.quotationMark || code === codes.apostrophe || code === codes.rightParenthesis || code === codes.asterisk || code === codes.comma || code === codes.dot || code === codes.colon || code === codes.semicolon || code === codes.questionMark || code === codes.underscore || code === codes.tilde) {\n      effects.consume(code);\n      return trail;\n    }\n\n    // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n    if (code === codes.ampersand) {\n      effects.consume(code);\n      return trailCharRefStart;\n    }\n\n    // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return trailBracketAfter;\n    }\n    if (\n    // `<` is an end.\n    code === codes.lessThan ||\n    // So is whitespace.\n    code === codes.eof || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n\n  /**\r\n   * In trail, after `]`.\r\n   *\r\n   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.\r\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com](\r\n   *                         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (code === codes.eof || code === codes.leftParenthesis || code === codes.leftSquareBracket || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return trail(code);\n  }\n\n  /**\r\n   * In character-reference like trail, after `&`.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com&amp;).\r\n   *                         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function trailCharRefStart(code) {\n    // When non-alpha, it’s not a trail.\n    return asciiAlpha(code) ? trailCharRefInside(code) : nok(code);\n  }\n\n  /**\r\n   * In character-reference like trail.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com&amp;).\r\n   *                         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function trailCharRefInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === codes.semicolon) {\n      effects.consume(code);\n      return trail;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return trailCharRefInside;\n    }\n\n    // It’s not a trail.\n    return nok(code);\n  }\n}\n\n/**\r\n * Dot in email domain trail.\r\n *\r\n * This calls `ok` if this *is* the trail, followed by an end, which means\r\n * the trail is not part of the link.\r\n * It calls `nok` if this *is* part of the link.\r\n *\r\n * ```markdown\r\n * > | contact@example.org.\r\n *                        ^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start;\n\n  /**\r\n   * Dot.\r\n   *\r\n   * ```markdown\r\n   * > | contact@example.org.\r\n   *                    ^   ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function start(code) {\n    // Must be dot.\n    effects.consume(code);\n    return after;\n  }\n\n  /**\r\n   * After dot.\r\n   *\r\n   * ```markdown\r\n   * > | contact@example.org.\r\n   *                     ^   ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return asciiAlphanumeric(code) ? nok(code) : ok(code);\n  }\n}\n\n/**\r\n * See:\r\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\r\n *\r\n * @type {Previous}\r\n */\nfunction previousWww(code) {\n  return code === codes.eof || code === codes.leftParenthesis || code === codes.asterisk || code === codes.underscore || code === codes.leftSquareBracket || code === codes.rightSquareBracket || code === codes.tilde || markdownLineEndingOrSpace(code);\n}\n\n/**\r\n * See:\r\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\r\n *\r\n * @type {Previous}\r\n */\nfunction previousProtocol(code) {\n  return !asciiAlpha(code);\n}\n\n/**\r\n * @this {TokenizeContext}\r\n * @type {Previous}\r\n */\nfunction previousEmail(code) {\n  // Do not allow a slash “inside” atext.\n  // The reference code is a bit weird, but that’s what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === codes.slash || gfmAtext(code));\n}\n\n/**\r\n * @param {Code} code\r\n * @returns {boolean}\r\n */\nfunction gfmAtext(code) {\n  return code === codes.plusSign || code === codes.dash || code === codes.dot || code === codes.underscore || asciiAlphanumeric(code);\n}\n\n/**\r\n * @param {Array<Event>} events\r\n * @returns {boolean}\r\n */\nfunction previousUnbalanced(events) {\n  let index = events.length;\n  let result = false;\n  while (index--) {\n    const token = events[index][1];\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\n      result = true;\n      break;\n    }\n\n    // If we’ve seen this token, and it was marked as not having any unbalanced\n    // bracket before it, we can exit.\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n  if (events.length > 0 && !result) {\n    // Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n  return result;\n}","map":{"version":3,"names":["asciiAlpha","asciiAlphanumeric","asciiControl","markdownLineEndingOrSpace","unicodePunctuation","unicodeWhitespace","codes","wwwPrefix","tokenize","tokenizeWwwPrefix","partial","domain","tokenizeDomain","path","tokenizePath","trail","tokenizeTrail","emailDomainDotTrail","tokenizeEmailDomainDotTrail","wwwAutolink","tokenizeWwwAutolink","previous","previousWww","protocolAutolink","tokenizeProtocolAutolink","previousProtocol","emailAutolink","tokenizeEmailAutolink","previousEmail","text","gfmAutolinkLiteral","code","digit0","leftCurlyBrace","colon","uppercaseA","leftSquareBracket","lowercaseA","plusSign","dash","dot","underscore","uppercaseH","lowercaseH","uppercaseW","lowercaseW","effects","ok","nok","self","data","start","gfmAtext","call","previousUnbalanced","events","enter","atext","consume","atSign","emailDomain","check","emailDomainAfter","emailDomainDot","exit","wwwStart","attempt","wwwAfter","buffer","seen","protocolStart","String","fromCodePoint","protocolPrefixInside","length","protocol","toLowerCase","protocolSlashesInside","slash","afterProtocol","eof","protocolAfter","size","wwwPrefixInside","wwwPrefixAfter","underscoreInLastSegment","underscoreInLastLastSegment","domainInside","domainAfter","domainAtPunctuation","undefined","sizeOpen","sizeClose","pathInside","leftParenthesis","rightParenthesis","pathAtPunctuation","exclamationMark","quotationMark","ampersand","apostrophe","asterisk","comma","semicolon","lessThan","questionMark","rightSquareBracket","tilde","trailCharRefStart","trailBracketAfter","trailCharRefInside","after","index","result","token","type","_balanced","_gfmAutolinkLiteralWalkedInto"],"sources":["E:/Documents/2024-1 YBIGTA/React/blog_git/Ybigta-Blog/frontend/node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').Code} Code\r\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\r\n * @typedef {import('micromark-util-types').Event} Event\r\n * @typedef {import('micromark-util-types').Extension} Extension\r\n * @typedef {import('micromark-util-types').Previous} Previous\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n */\r\n\r\nimport {\r\n  asciiAlpha,\r\n  asciiAlphanumeric,\r\n  asciiControl,\r\n  markdownLineEndingOrSpace,\r\n  unicodePunctuation,\r\n  unicodeWhitespace\r\n} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol'\r\n\r\nconst wwwPrefix = {tokenize: tokenizeWwwPrefix, partial: true}\r\nconst domain = {tokenize: tokenizeDomain, partial: true}\r\nconst path = {tokenize: tokenizePath, partial: true}\r\nconst trail = {tokenize: tokenizeTrail, partial: true}\r\nconst emailDomainDotTrail = {\r\n  tokenize: tokenizeEmailDomainDotTrail,\r\n  partial: true\r\n}\r\n\r\nconst wwwAutolink = {tokenize: tokenizeWwwAutolink, previous: previousWww}\r\nconst protocolAutolink = {\r\n  tokenize: tokenizeProtocolAutolink,\r\n  previous: previousProtocol\r\n}\r\nconst emailAutolink = {tokenize: tokenizeEmailAutolink, previous: previousEmail}\r\n\r\n/** @type {ConstructRecord} */\r\nconst text = {}\r\n\r\n/**\r\n * Create an extension for `micromark` to support GitHub autolink literal\r\n * syntax.\r\n *\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\r\n *   autolink literal syntax.\r\n */\r\nexport function gfmAutolinkLiteral() {\r\n  return {text}\r\n}\r\n\r\n/** @type {Code} */\r\nlet code = codes.digit0\r\n\r\n// Add alphanumerics.\r\nwhile (code < codes.leftCurlyBrace) {\r\n  text[code] = emailAutolink\r\n  code++\r\n  if (code === codes.colon) code = codes.uppercaseA\r\n  else if (code === codes.leftSquareBracket) code = codes.lowercaseA\r\n}\r\n\r\ntext[codes.plusSign] = emailAutolink\r\ntext[codes.dash] = emailAutolink\r\ntext[codes.dot] = emailAutolink\r\ntext[codes.underscore] = emailAutolink\r\ntext[codes.uppercaseH] = [emailAutolink, protocolAutolink]\r\ntext[codes.lowercaseH] = [emailAutolink, protocolAutolink]\r\ntext[codes.uppercaseW] = [emailAutolink, wwwAutolink]\r\ntext[codes.lowercaseW] = [emailAutolink, wwwAutolink]\r\n\r\n// To do: perform email autolink literals on events, afterwards.\r\n// That’s where `markdown-rs` and `cmark-gfm` perform it.\r\n// It should look for `@`, then for atext backwards, and then for a label\r\n// forwards.\r\n// To do: `mailto:`, `xmpp:` protocol as prefix.\r\n\r\n/**\r\n * Email autolink literal.\r\n *\r\n * ```markdown\r\n * > | a contact@example.org b\r\n *       ^^^^^^^^^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeEmailAutolink(effects, ok, nok) {\r\n  const self = this\r\n  /** @type {boolean | undefined} */\r\n  let dot\r\n  /** @type {boolean} */\r\n  let data\r\n\r\n  return start\r\n\r\n  /**\r\n   * Start of email autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    if (\r\n      !gfmAtext(code) ||\r\n      !previousEmail.call(self, self.previous) ||\r\n      previousUnbalanced(self.events)\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.enter('literalAutolink')\r\n    effects.enter('literalAutolinkEmail')\r\n    return atext(code)\r\n  }\r\n\r\n  /**\r\n   * In email atext.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function atext(code) {\r\n    if (gfmAtext(code)) {\r\n      effects.consume(code)\r\n      return atext\r\n    }\r\n\r\n    if (code === codes.atSign) {\r\n      effects.consume(code)\r\n      return emailDomain\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * In email domain.\r\n   *\r\n   * The reference code is a bit overly complex as it handles the `@`, of which\r\n   * there may be just one.\r\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *               ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function emailDomain(code) {\r\n    // Dot followed by alphanumerical (not `-` or `_`).\r\n    if (code === codes.dot) {\r\n      return effects.check(\r\n        emailDomainDotTrail,\r\n        emailDomainAfter,\r\n        emailDomainDot\r\n      )(code)\r\n    }\r\n\r\n    // Alphanumerical, `-`, and `_`.\r\n    if (\r\n      code === codes.dash ||\r\n      code === codes.underscore ||\r\n      asciiAlphanumeric(code)\r\n    ) {\r\n      data = true\r\n      effects.consume(code)\r\n      return emailDomain\r\n    }\r\n\r\n    // To do: `/` if xmpp.\r\n\r\n    // Note: normally we’d truncate trailing punctuation from the link.\r\n    // However, email autolink literals cannot contain any of those markers,\r\n    // except for `.`, but that can only occur if it isn’t trailing.\r\n    // So we can ignore truncating!\r\n    return emailDomainAfter(code)\r\n  }\r\n\r\n  /**\r\n   * In email domain, on dot that is not a trail.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *                      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function emailDomainDot(code) {\r\n    effects.consume(code)\r\n    dot = true\r\n    return emailDomain\r\n  }\r\n\r\n  /**\r\n   * After email domain.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *                          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function emailDomainAfter(code) {\r\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\r\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\r\n    if (data && dot && asciiAlpha(self.previous)) {\r\n      effects.exit('literalAutolinkEmail')\r\n      effects.exit('literalAutolink')\r\n      return ok(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * `www` autolink literal.\r\n *\r\n * ```markdown\r\n * > | a www.example.org b\r\n *       ^^^^^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeWwwAutolink(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return wwwStart\r\n\r\n  /**\r\n   * Start of www autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com/a?b#c\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function wwwStart(code) {\r\n    if (\r\n      (code !== codes.uppercaseW && code !== codes.lowercaseW) ||\r\n      !previousWww.call(self, self.previous) ||\r\n      previousUnbalanced(self.events)\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.enter('literalAutolink')\r\n    effects.enter('literalAutolinkWww')\r\n    // Note: we *check*, so we can discard the `www.` we parsed.\r\n    // If it worked, we consider it as a part of the domain.\r\n    return effects.check(\r\n      wwwPrefix,\r\n      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),\r\n      nok\r\n    )(code)\r\n  }\r\n\r\n  /**\r\n   * After a www autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com/a?b#c\r\n   *                          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function wwwAfter(code) {\r\n    effects.exit('literalAutolinkWww')\r\n    effects.exit('literalAutolink')\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * Protocol autolink literal.\r\n *\r\n * ```markdown\r\n * > | a https://example.org b\r\n *       ^^^^^^^^^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\r\n  const self = this\r\n  let buffer = ''\r\n  let seen = false\r\n\r\n  return protocolStart\r\n\r\n  /**\r\n   * Start of protocol autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function protocolStart(code) {\r\n    if (\r\n      (code === codes.uppercaseH || code === codes.lowercaseH) &&\r\n      previousProtocol.call(self, self.previous) &&\r\n      !previousUnbalanced(self.events)\r\n    ) {\r\n      effects.enter('literalAutolink')\r\n      effects.enter('literalAutolinkHttp')\r\n      buffer += String.fromCodePoint(code)\r\n      effects.consume(code)\r\n      return protocolPrefixInside\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * In protocol.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *     ^^^^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function protocolPrefixInside(code) {\r\n    // `5` is size of `https`\r\n    if (asciiAlpha(code) && buffer.length < 5) {\r\n      // @ts-expect-error: definitely number.\r\n      buffer += String.fromCodePoint(code)\r\n      effects.consume(code)\r\n      return protocolPrefixInside\r\n    }\r\n\r\n    if (code === codes.colon) {\r\n      const protocol = buffer.toLowerCase()\r\n\r\n      if (protocol === 'http' || protocol === 'https') {\r\n        effects.consume(code)\r\n        return protocolSlashesInside\r\n      }\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * In slashes.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *           ^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function protocolSlashesInside(code) {\r\n    if (code === codes.slash) {\r\n      effects.consume(code)\r\n\r\n      if (seen) {\r\n        return afterProtocol\r\n      }\r\n\r\n      seen = true\r\n      return protocolSlashesInside\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * After protocol, before domain.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *             ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function afterProtocol(code) {\r\n    // To do: this is different from `markdown-rs`:\r\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\r\n    return code === codes.eof ||\r\n      asciiControl(code) ||\r\n      markdownLineEndingOrSpace(code) ||\r\n      unicodeWhitespace(code) ||\r\n      unicodePunctuation(code)\r\n      ? nok(code)\r\n      : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code)\r\n  }\r\n\r\n  /**\r\n   * After a protocol autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *                              ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function protocolAfter(code) {\r\n    effects.exit('literalAutolinkHttp')\r\n    effects.exit('literalAutolink')\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * `www` prefix.\r\n *\r\n * ```markdown\r\n * > | a www.example.org b\r\n *       ^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeWwwPrefix(effects, ok, nok) {\r\n  let size = 0\r\n\r\n  return wwwPrefixInside\r\n\r\n  /**\r\n   * In www prefix.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com\r\n   *     ^^^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function wwwPrefixInside(code) {\r\n    if ((code === codes.uppercaseW || code === codes.lowercaseW) && size < 3) {\r\n      size++\r\n      effects.consume(code)\r\n      return wwwPrefixInside\r\n    }\r\n\r\n    if (code === codes.dot && size === 3) {\r\n      effects.consume(code)\r\n      return wwwPrefixAfter\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * After www prefix.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function wwwPrefixAfter(code) {\r\n    // If there is *anything*, we can link.\r\n    return code === codes.eof ? nok(code) : ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * Domain.\r\n *\r\n * ```markdown\r\n * > | a https://example.org b\r\n *               ^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeDomain(effects, ok, nok) {\r\n  /** @type {boolean | undefined} */\r\n  let underscoreInLastSegment\r\n  /** @type {boolean | undefined} */\r\n  let underscoreInLastLastSegment\r\n  /** @type {boolean | undefined} */\r\n  let seen\r\n\r\n  return domainInside\r\n\r\n  /**\r\n   * In domain.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\r\n   *             ^^^^^^^^^^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function domainInside(code) {\r\n    // Check whether this marker, which is a trailing punctuation\r\n    // marker, optionally followed by more trailing markers, and then\r\n    // followed by an end.\r\n    if (code === codes.dot || code === codes.underscore) {\r\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code)\r\n    }\r\n\r\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\r\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\r\n    // so that’s Unicode.\r\n    // Instead of some new production for Unicode alphanumerics, markdown\r\n    // already has that for Unicode punctuation and whitespace, so use those.\r\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\r\n    if (\r\n      code === codes.eof ||\r\n      markdownLineEndingOrSpace(code) ||\r\n      unicodeWhitespace(code) ||\r\n      (code !== codes.dash && unicodePunctuation(code))\r\n    ) {\r\n      return domainAfter(code)\r\n    }\r\n\r\n    seen = true\r\n    effects.consume(code)\r\n    return domainInside\r\n  }\r\n\r\n  /**\r\n   * In domain, at potential trailing punctuation, that was not trailing.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com\r\n   *                    ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function domainAtPunctuation(code) {\r\n    // There is an underscore in the last segment of the domain\r\n    if (code === codes.underscore) {\r\n      underscoreInLastSegment = true\r\n    }\r\n    // Otherwise, it’s a `.`: save the last segment underscore in the\r\n    // penultimate segment slot.\r\n    else {\r\n      underscoreInLastLastSegment = underscoreInLastSegment\r\n      underscoreInLastSegment = undefined\r\n    }\r\n\r\n    effects.consume(code)\r\n    return domainInside\r\n  }\r\n\r\n  /**\r\n   * After domain.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\r\n   *                        ^\r\n   * ```\r\n   *\r\n   * @type {State} */\r\n  function domainAfter(code) {\r\n    // Note: that’s GH says a dot is needed, but it’s not true:\r\n    // <https://github.com/github/cmark-gfm/issues/279>\r\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\r\n      return nok(code)\r\n    }\r\n\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * Path.\r\n *\r\n * ```markdown\r\n * > | a https://example.org/stuff b\r\n *                          ^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizePath(effects, ok) {\r\n  let sizeOpen = 0\r\n  let sizeClose = 0\r\n\r\n  return pathInside\r\n\r\n  /**\r\n   * In path.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\r\n   *                        ^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function pathInside(code) {\r\n    if (code === codes.leftParenthesis) {\r\n      sizeOpen++\r\n      effects.consume(code)\r\n      return pathInside\r\n    }\r\n\r\n    // To do: `markdown-rs` also needs this.\r\n    // If this is a paren, and there are less closings than openings,\r\n    // we don’t check for a trail.\r\n    if (code === codes.rightParenthesis && sizeClose < sizeOpen) {\r\n      return pathAtPunctuation(code)\r\n    }\r\n\r\n    // Check whether this trailing punctuation marker is optionally\r\n    // followed by more trailing markers, and then followed\r\n    // by an end.\r\n    if (\r\n      code === codes.exclamationMark ||\r\n      code === codes.quotationMark ||\r\n      code === codes.ampersand ||\r\n      code === codes.apostrophe ||\r\n      code === codes.rightParenthesis ||\r\n      code === codes.asterisk ||\r\n      code === codes.comma ||\r\n      code === codes.dot ||\r\n      code === codes.colon ||\r\n      code === codes.semicolon ||\r\n      code === codes.lessThan ||\r\n      code === codes.questionMark ||\r\n      code === codes.rightSquareBracket ||\r\n      code === codes.underscore ||\r\n      code === codes.tilde\r\n    ) {\r\n      return effects.check(trail, ok, pathAtPunctuation)(code)\r\n    }\r\n\r\n    if (\r\n      code === codes.eof ||\r\n      markdownLineEndingOrSpace(code) ||\r\n      unicodeWhitespace(code)\r\n    ) {\r\n      return ok(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return pathInside\r\n  }\r\n\r\n  /**\r\n   * In path, at potential trailing punctuation, that was not trailing.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\"b\r\n   *                          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function pathAtPunctuation(code) {\r\n    // Count closing parens.\r\n    if (code === codes.rightParenthesis) {\r\n      sizeClose++\r\n    }\r\n\r\n    effects.consume(code)\r\n    return pathInside\r\n  }\r\n}\r\n\r\n/**\r\n * Trail.\r\n *\r\n * This calls `ok` if this *is* the trail, followed by an end, which means\r\n * the entire trail is not part of the link.\r\n * It calls `nok` if this *is* part of the link.\r\n *\r\n * ```markdown\r\n * > | https://example.com\").\r\n *                        ^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeTrail(effects, ok, nok) {\r\n  return trail\r\n\r\n  /**\r\n   * In trail of domain or path.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com\").\r\n   *                        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function trail(code) {\r\n    // Regular trailing punctuation.\r\n    if (\r\n      code === codes.exclamationMark ||\r\n      code === codes.quotationMark ||\r\n      code === codes.apostrophe ||\r\n      code === codes.rightParenthesis ||\r\n      code === codes.asterisk ||\r\n      code === codes.comma ||\r\n      code === codes.dot ||\r\n      code === codes.colon ||\r\n      code === codes.semicolon ||\r\n      code === codes.questionMark ||\r\n      code === codes.underscore ||\r\n      code === codes.tilde\r\n    ) {\r\n      effects.consume(code)\r\n      return trail\r\n    }\r\n\r\n    // `&` followed by one or more alphabeticals and then a `;`, is\r\n    // as a whole considered as trailing punctuation.\r\n    // In all other cases, it is considered as continuation of the URL.\r\n    if (code === codes.ampersand) {\r\n      effects.consume(code)\r\n      return trailCharRefStart\r\n    }\r\n\r\n    // Needed because we allow literals after `[`, as we fix:\r\n    // <https://github.com/github/cmark-gfm/issues/278>.\r\n    // Check that it is not followed by `(` or `[`.\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.consume(code)\r\n      return trailBracketAfter\r\n    }\r\n\r\n    if (\r\n      // `<` is an end.\r\n      code === codes.lessThan ||\r\n      // So is whitespace.\r\n      code === codes.eof ||\r\n      markdownLineEndingOrSpace(code) ||\r\n      unicodeWhitespace(code)\r\n    ) {\r\n      return ok(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * In trail, after `]`.\r\n   *\r\n   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.\r\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com](\r\n   *                         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function trailBracketAfter(code) {\r\n    // Whitespace or something that could start a resource or reference is the end.\r\n    // Switch back to trail otherwise.\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.leftParenthesis ||\r\n      code === codes.leftSquareBracket ||\r\n      markdownLineEndingOrSpace(code) ||\r\n      unicodeWhitespace(code)\r\n    ) {\r\n      return ok(code)\r\n    }\r\n\r\n    return trail(code)\r\n  }\r\n\r\n  /**\r\n   * In character-reference like trail, after `&`.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com&amp;).\r\n   *                         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function trailCharRefStart(code) {\r\n    // When non-alpha, it’s not a trail.\r\n    return asciiAlpha(code) ? trailCharRefInside(code) : nok(code)\r\n  }\r\n\r\n  /**\r\n   * In character-reference like trail.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com&amp;).\r\n   *                         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function trailCharRefInside(code) {\r\n    // Switch back to trail if this is well-formed.\r\n    if (code === codes.semicolon) {\r\n      effects.consume(code)\r\n      return trail\r\n    }\r\n\r\n    if (asciiAlpha(code)) {\r\n      effects.consume(code)\r\n      return trailCharRefInside\r\n    }\r\n\r\n    // It’s not a trail.\r\n    return nok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * Dot in email domain trail.\r\n *\r\n * This calls `ok` if this *is* the trail, followed by an end, which means\r\n * the trail is not part of the link.\r\n * It calls `nok` if this *is* part of the link.\r\n *\r\n * ```markdown\r\n * > | contact@example.org.\r\n *                        ^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\r\n  return start\r\n\r\n  /**\r\n   * Dot.\r\n   *\r\n   * ```markdown\r\n   * > | contact@example.org.\r\n   *                    ^   ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    // Must be dot.\r\n    effects.consume(code)\r\n    return after\r\n  }\r\n\r\n  /**\r\n   * After dot.\r\n   *\r\n   * ```markdown\r\n   * > | contact@example.org.\r\n   *                     ^   ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function after(code) {\r\n    // Not a trail if alphanumeric.\r\n    return asciiAlphanumeric(code) ? nok(code) : ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * See:\r\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\r\n *\r\n * @type {Previous}\r\n */\r\nfunction previousWww(code) {\r\n  return (\r\n    code === codes.eof ||\r\n    code === codes.leftParenthesis ||\r\n    code === codes.asterisk ||\r\n    code === codes.underscore ||\r\n    code === codes.leftSquareBracket ||\r\n    code === codes.rightSquareBracket ||\r\n    code === codes.tilde ||\r\n    markdownLineEndingOrSpace(code)\r\n  )\r\n}\r\n\r\n/**\r\n * See:\r\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\r\n *\r\n * @type {Previous}\r\n */\r\nfunction previousProtocol(code) {\r\n  return !asciiAlpha(code)\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Previous}\r\n */\r\nfunction previousEmail(code) {\r\n  // Do not allow a slash “inside” atext.\r\n  // The reference code is a bit weird, but that’s what it results in.\r\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\r\n  // Other than slash, every preceding character is allowed.\r\n  return !(code === codes.slash || gfmAtext(code))\r\n}\r\n\r\n/**\r\n * @param {Code} code\r\n * @returns {boolean}\r\n */\r\nfunction gfmAtext(code) {\r\n  return (\r\n    code === codes.plusSign ||\r\n    code === codes.dash ||\r\n    code === codes.dot ||\r\n    code === codes.underscore ||\r\n    asciiAlphanumeric(code)\r\n  )\r\n}\r\n\r\n/**\r\n * @param {Array<Event>} events\r\n * @returns {boolean}\r\n */\r\nfunction previousUnbalanced(events) {\r\n  let index = events.length\r\n  let result = false\r\n\r\n  while (index--) {\r\n    const token = events[index][1]\r\n\r\n    if (\r\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\r\n      !token._balanced\r\n    ) {\r\n      result = true\r\n      break\r\n    }\r\n\r\n    // If we’ve seen this token, and it was marked as not having any unbalanced\r\n    // bracket before it, we can exit.\r\n    if (token._gfmAutolinkLiteralWalkedInto) {\r\n      result = false\r\n      break\r\n    }\r\n  }\r\n\r\n  if (events.length > 0 && !result) {\r\n    // Mark the last token as “walked into” w/o finding\r\n    // anything.\r\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\r\n  }\r\n\r\n  return result\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}