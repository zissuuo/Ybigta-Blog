{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').Event} Event\r\n */\n\n/**\r\n * @typedef {'center' | 'left' | 'none' | 'right'} Align\r\n */\n\nimport { ok as assert } from 'devlop';\n\n/**\r\n * Figure out the alignment of a GFM table.\r\n *\r\n * @param {Readonly<Array<Event>>} events\r\n *   List of events.\r\n * @param {number} index\r\n *   Table enter event.\r\n * @returns {Array<Align>}\r\n *   List of aligns.\r\n */\nexport function gfmTableAlign(events, index) {\n  assert(events[index][1].type === 'table', 'expected table');\n  let inDelimiterRow = false;\n  /** @type {Array<Align>} */\n  const align = [];\n  while (index < events.length) {\n    const event = events[index];\n    if (inDelimiterRow) {\n      if (event[0] === 'enter') {\n        // Start of alignment value: set a new column.\n        // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n        if (event[1].type === 'tableContent') {\n          align.push(events[index + 1][1].type === 'tableDelimiterMarker' ? 'left' : 'none');\n        }\n      }\n      // Exits:\n      // End of alignment value: change the column.\n      // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n      else if (event[1].type === 'tableContent') {\n        if (events[index - 1][1].type === 'tableDelimiterMarker') {\n          const alignIndex = align.length - 1;\n          align[alignIndex] = align[alignIndex] === 'left' ? 'center' : 'right';\n        }\n      }\n      // Done!\n      else if (event[1].type === 'tableDelimiterRow') {\n        break;\n      }\n    } else if (event[0] === 'enter' && event[1].type === 'tableDelimiterRow') {\n      inDelimiterRow = true;\n    }\n    index += 1;\n  }\n  return align;\n}","map":{"version":3,"names":["ok","assert","gfmTableAlign","events","index","type","inDelimiterRow","align","length","event","push","alignIndex"],"sources":["E:/Documents/2024-1 YBIGTA/React/blog_git/Ybigta-Blog/frontend/node_modules/micromark-extension-gfm-table/dev/lib/infer.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').Event} Event\r\n */\r\n\r\n/**\r\n * @typedef {'center' | 'left' | 'none' | 'right'} Align\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\n\r\n/**\r\n * Figure out the alignment of a GFM table.\r\n *\r\n * @param {Readonly<Array<Event>>} events\r\n *   List of events.\r\n * @param {number} index\r\n *   Table enter event.\r\n * @returns {Array<Align>}\r\n *   List of aligns.\r\n */\r\nexport function gfmTableAlign(events, index) {\r\n  assert(events[index][1].type === 'table', 'expected table')\r\n  let inDelimiterRow = false\r\n  /** @type {Array<Align>} */\r\n  const align = []\r\n\r\n  while (index < events.length) {\r\n    const event = events[index]\r\n\r\n    if (inDelimiterRow) {\r\n      if (event[0] === 'enter') {\r\n        // Start of alignment value: set a new column.\r\n        // To do: `markdown-rs` uses `tableDelimiterCellValue`.\r\n        if (event[1].type === 'tableContent') {\r\n          align.push(\r\n            events[index + 1][1].type === 'tableDelimiterMarker'\r\n              ? 'left'\r\n              : 'none'\r\n          )\r\n        }\r\n      }\r\n      // Exits:\r\n      // End of alignment value: change the column.\r\n      // To do: `markdown-rs` uses `tableDelimiterCellValue`.\r\n      else if (event[1].type === 'tableContent') {\r\n        if (events[index - 1][1].type === 'tableDelimiterMarker') {\r\n          const alignIndex = align.length - 1\r\n\r\n          align[alignIndex] = align[alignIndex] === 'left' ? 'center' : 'right'\r\n        }\r\n      }\r\n      // Done!\r\n      else if (event[1].type === 'tableDelimiterRow') {\r\n        break\r\n      }\r\n    } else if (event[0] === 'enter' && event[1].type === 'tableDelimiterRow') {\r\n      inDelimiterRow = true\r\n    }\r\n\r\n    index += 1\r\n  }\r\n\r\n  return align\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAQA,EAAE,IAAIC,MAAM,QAAO,QAAQ;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAACC,MAAM,EAAEC,KAAK,EAAE;EAC3CH,MAAM,CAACE,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,KAAK,OAAO,EAAE,gBAAgB,CAAC;EAC3D,IAAIC,cAAc,GAAG,KAAK;EAC1B;EACA,MAAMC,KAAK,GAAG,EAAE;EAEhB,OAAOH,KAAK,GAAGD,MAAM,CAACK,MAAM,EAAE;IAC5B,MAAMC,KAAK,GAAGN,MAAM,CAACC,KAAK,CAAC;IAE3B,IAAIE,cAAc,EAAE;MAClB,IAAIG,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;QACxB;QACA;QACA,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACJ,IAAI,KAAK,cAAc,EAAE;UACpCE,KAAK,CAACG,IAAI,CACRP,MAAM,CAACC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,KAAK,sBAAsB,GAChD,MAAM,GACN,MACN,CAAC;QACH;MACF;MACA;MACA;MACA;MAAA,KACK,IAAII,KAAK,CAAC,CAAC,CAAC,CAACJ,IAAI,KAAK,cAAc,EAAE;QACzC,IAAIF,MAAM,CAACC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,KAAK,sBAAsB,EAAE;UACxD,MAAMM,UAAU,GAAGJ,KAAK,CAACC,MAAM,GAAG,CAAC;UAEnCD,KAAK,CAACI,UAAU,CAAC,GAAGJ,KAAK,CAACI,UAAU,CAAC,KAAK,MAAM,GAAG,QAAQ,GAAG,OAAO;QACvE;MACF;MACA;MAAA,KACK,IAAIF,KAAK,CAAC,CAAC,CAAC,CAACJ,IAAI,KAAK,mBAAmB,EAAE;QAC9C;MACF;IACF,CAAC,MAAM,IAAII,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACJ,IAAI,KAAK,mBAAmB,EAAE;MACxEC,cAAc,GAAG,IAAI;IACvB;IAEAF,KAAK,IAAI,CAAC;EACZ;EAEA,OAAOG,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}