{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').Event} Event\r\n */\n\n// Port of `edit_map.rs` from `markdown-rs`.\n// This should move to `markdown-js` later.\n\n// Deal with several changes in events, batching them together.\n//\n// Preferably, changes should be kept to a minimum.\n// Sometimes, it’s needed to change the list of events, because parsing can be\n// messy, and it helps to expose a cleaner interface of events to the compiler\n// and other users.\n// It can also help to merge many adjacent similar events.\n// And, in other cases, it’s needed to parse subcontent: pass some events\n// through another tokenizer and inject the result.\n\n/**\r\n * @typedef {[number, number, Array<Event>]} Change\r\n * @typedef {[number, number, number]} Jump\r\n */\n\n/**\r\n * Tracks a bunch of edits.\r\n */\nexport class EditMap {\n  /**\r\n   * Create a new edit map.\r\n   */\n  constructor() {\n    /**\r\n     * Record of changes.\r\n     *\r\n     * @type {Array<Change>}\r\n     */\n    this.map = [];\n  }\n\n  /**\r\n   * Create an edit: a remove and/or add at a certain place.\r\n   *\r\n   * @param {number} index\r\n   * @param {number} remove\r\n   * @param {Array<Event>} add\r\n   * @returns {undefined}\r\n   */\n  add(index, remove, add) {\n    addImpl(this, index, remove, add);\n  }\n\n  // To do: add this when moving to `micromark`.\n  // /**\n  //  * Create an edit: but insert `add` before existing additions.\n  //  *\n  //  * @param {number} index\n  //  * @param {number} remove\n  //  * @param {Array<Event>} add\n  //  * @returns {undefined}\n  //  */\n  // addBefore(index, remove, add) {\n  //   addImpl(this, index, remove, add, true)\n  // }\n\n  /**\r\n   * Done, change the events.\r\n   *\r\n   * @param {Array<Event>} events\r\n   * @returns {undefined}\r\n   */\n  consume(events) {\n    this.map.sort(function (a, b) {\n      return a[0] - b[0];\n    });\n\n    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n    if (this.map.length === 0) {\n      return;\n    }\n\n    // To do: if links are added in events, like they are in `markdown-rs`,\n    // this is needed.\n    // // Calculate jumps: where items in the current list move to.\n    // /** @type {Array<Jump>} */\n    // const jumps = []\n    // let index = 0\n    // let addAcc = 0\n    // let removeAcc = 0\n    // while (index < this.map.length) {\n    //   const [at, remove, add] = this.map[index]\n    //   removeAcc += remove\n    //   addAcc += add.length\n    //   jumps.push([at, removeAcc, addAcc])\n    //   index += 1\n    // }\n    //\n    // . shiftLinks(events, jumps)\n\n    let index = this.map.length;\n    /** @type {Array<Array<Event>>} */\n    const vecs = [];\n    while (index > 0) {\n      index -= 1;\n      vecs.push(events.slice(this.map[index][0] + this.map[index][1]), this.map[index][2]);\n\n      // Truncate rest.\n      events.length = this.map[index][0];\n    }\n    vecs.push([...events]);\n    events.length = 0;\n    let slice = vecs.pop();\n    while (slice) {\n      events.push(...slice);\n      slice = vecs.pop();\n    }\n\n    // Truncate everything.\n    this.map.length = 0;\n  }\n}\n\n/**\r\n * Create an edit.\r\n *\r\n * @param {EditMap} editMap\r\n * @param {number} at\r\n * @param {number} remove\r\n * @param {Array<Event>} add\r\n * @returns {undefined}\r\n */\nfunction addImpl(editMap, at, remove, add) {\n  let index = 0;\n\n  /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n  if (remove === 0 && add.length === 0) {\n    return;\n  }\n  while (index < editMap.map.length) {\n    if (editMap.map[index][0] === at) {\n      editMap.map[index][1] += remove;\n\n      // To do: before not used by tables, use when moving to micromark.\n      // if (before) {\n      //   add.push(...editMap.map[index][2])\n      //   editMap.map[index][2] = add\n      // } else {\n      editMap.map[index][2].push(...add);\n      // }\n\n      return;\n    }\n    index += 1;\n  }\n  editMap.map.push([at, remove, add]);\n}\n\n// /**\n//  * Shift `previous` and `next` links according to `jumps`.\n//  *\n//  * This fixes links in case there are events removed or added between them.\n//  *\n//  * @param {Array<Event>} events\n//  * @param {Array<Jump>} jumps\n//  */\n// function shiftLinks(events, jumps) {\n//   let jumpIndex = 0\n//   let index = 0\n//   let add = 0\n//   let rm = 0\n\n//   while (index < events.length) {\n//     const rmCurr = rm\n\n//     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\n//       add = jumps[jumpIndex][2]\n//       rm = jumps[jumpIndex][1]\n//       jumpIndex += 1\n//     }\n\n//     // Ignore items that will be removed.\n//     if (rm > rmCurr) {\n//       index += rm - rmCurr\n//     } else {\n//       // ?\n//       // if let Some(link) = &events[index].link {\n//       //     if let Some(next) = link.next {\n//       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\n//       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\n//       //             add = jumps[jumpIndex].2;\n//       //             rm = jumps[jumpIndex].1;\n//       //             jumpIndex += 1;\n//       //         }\n//       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\n//       //         index = next;\n//       //         continue;\n//       //     }\n//       // }\n//       index += 1\n//     }\n//   }\n// }","map":{"version":3,"names":["EditMap","constructor","map","add","index","remove","addImpl","consume","events","sort","a","b","length","vecs","push","slice","pop","editMap","at"],"sources":["E:/Documents/2024-1 YBIGTA/Ybigta_BLOG/blog_git/Ybigta-Blog/frontend/node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').Event} Event\r\n */\r\n\r\n// Port of `edit_map.rs` from `markdown-rs`.\r\n// This should move to `markdown-js` later.\r\n\r\n// Deal with several changes in events, batching them together.\r\n//\r\n// Preferably, changes should be kept to a minimum.\r\n// Sometimes, it’s needed to change the list of events, because parsing can be\r\n// messy, and it helps to expose a cleaner interface of events to the compiler\r\n// and other users.\r\n// It can also help to merge many adjacent similar events.\r\n// And, in other cases, it’s needed to parse subcontent: pass some events\r\n// through another tokenizer and inject the result.\r\n\r\n/**\r\n * @typedef {[number, number, Array<Event>]} Change\r\n * @typedef {[number, number, number]} Jump\r\n */\r\n\r\n/**\r\n * Tracks a bunch of edits.\r\n */\r\nexport class EditMap {\r\n  /**\r\n   * Create a new edit map.\r\n   */\r\n  constructor() {\r\n    /**\r\n     * Record of changes.\r\n     *\r\n     * @type {Array<Change>}\r\n     */\r\n    this.map = []\r\n  }\r\n\r\n  /**\r\n   * Create an edit: a remove and/or add at a certain place.\r\n   *\r\n   * @param {number} index\r\n   * @param {number} remove\r\n   * @param {Array<Event>} add\r\n   * @returns {undefined}\r\n   */\r\n  add(index, remove, add) {\r\n    addImpl(this, index, remove, add)\r\n  }\r\n\r\n  // To do: add this when moving to `micromark`.\r\n  // /**\r\n  //  * Create an edit: but insert `add` before existing additions.\r\n  //  *\r\n  //  * @param {number} index\r\n  //  * @param {number} remove\r\n  //  * @param {Array<Event>} add\r\n  //  * @returns {undefined}\r\n  //  */\r\n  // addBefore(index, remove, add) {\r\n  //   addImpl(this, index, remove, add, true)\r\n  // }\r\n\r\n  /**\r\n   * Done, change the events.\r\n   *\r\n   * @param {Array<Event>} events\r\n   * @returns {undefined}\r\n   */\r\n  consume(events) {\r\n    this.map.sort(function (a, b) {\r\n      return a[0] - b[0]\r\n    })\r\n\r\n    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\r\n    if (this.map.length === 0) {\r\n      return\r\n    }\r\n\r\n    // To do: if links are added in events, like they are in `markdown-rs`,\r\n    // this is needed.\r\n    // // Calculate jumps: where items in the current list move to.\r\n    // /** @type {Array<Jump>} */\r\n    // const jumps = []\r\n    // let index = 0\r\n    // let addAcc = 0\r\n    // let removeAcc = 0\r\n    // while (index < this.map.length) {\r\n    //   const [at, remove, add] = this.map[index]\r\n    //   removeAcc += remove\r\n    //   addAcc += add.length\r\n    //   jumps.push([at, removeAcc, addAcc])\r\n    //   index += 1\r\n    // }\r\n    //\r\n    // . shiftLinks(events, jumps)\r\n\r\n    let index = this.map.length\r\n    /** @type {Array<Array<Event>>} */\r\n    const vecs = []\r\n    while (index > 0) {\r\n      index -= 1\r\n      vecs.push(\r\n        events.slice(this.map[index][0] + this.map[index][1]),\r\n        this.map[index][2]\r\n      )\r\n\r\n      // Truncate rest.\r\n      events.length = this.map[index][0]\r\n    }\r\n\r\n    vecs.push([...events])\r\n    events.length = 0\r\n\r\n    let slice = vecs.pop()\r\n\r\n    while (slice) {\r\n      events.push(...slice)\r\n      slice = vecs.pop()\r\n    }\r\n\r\n    // Truncate everything.\r\n    this.map.length = 0\r\n  }\r\n}\r\n\r\n/**\r\n * Create an edit.\r\n *\r\n * @param {EditMap} editMap\r\n * @param {number} at\r\n * @param {number} remove\r\n * @param {Array<Event>} add\r\n * @returns {undefined}\r\n */\r\nfunction addImpl(editMap, at, remove, add) {\r\n  let index = 0\r\n\r\n  /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\r\n  if (remove === 0 && add.length === 0) {\r\n    return\r\n  }\r\n\r\n  while (index < editMap.map.length) {\r\n    if (editMap.map[index][0] === at) {\r\n      editMap.map[index][1] += remove\r\n\r\n      // To do: before not used by tables, use when moving to micromark.\r\n      // if (before) {\r\n      //   add.push(...editMap.map[index][2])\r\n      //   editMap.map[index][2] = add\r\n      // } else {\r\n      editMap.map[index][2].push(...add)\r\n      // }\r\n\r\n      return\r\n    }\r\n\r\n    index += 1\r\n  }\r\n\r\n  editMap.map.push([at, remove, add])\r\n}\r\n\r\n// /**\r\n//  * Shift `previous` and `next` links according to `jumps`.\r\n//  *\r\n//  * This fixes links in case there are events removed or added between them.\r\n//  *\r\n//  * @param {Array<Event>} events\r\n//  * @param {Array<Jump>} jumps\r\n//  */\r\n// function shiftLinks(events, jumps) {\r\n//   let jumpIndex = 0\r\n//   let index = 0\r\n//   let add = 0\r\n//   let rm = 0\r\n\r\n//   while (index < events.length) {\r\n//     const rmCurr = rm\r\n\r\n//     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\r\n//       add = jumps[jumpIndex][2]\r\n//       rm = jumps[jumpIndex][1]\r\n//       jumpIndex += 1\r\n//     }\r\n\r\n//     // Ignore items that will be removed.\r\n//     if (rm > rmCurr) {\r\n//       index += rm - rmCurr\r\n//     } else {\r\n//       // ?\r\n//       // if let Some(link) = &events[index].link {\r\n//       //     if let Some(next) = link.next {\r\n//       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\r\n//       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\r\n//       //             add = jumps[jumpIndex].2;\r\n//       //             rm = jumps[jumpIndex].1;\r\n//       //             jumpIndex += 1;\r\n//       //         }\r\n//       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\r\n//       //         index = next;\r\n//       //         continue;\r\n//       //     }\r\n//       // }\r\n//       index += 1\r\n//     }\r\n//   }\r\n// }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}