{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').Event} Event\r\n * @typedef {import('micromark-util-types').Extension} Extension\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n *\r\n * @typedef Options\r\n *   Configuration (optional).\r\n * @property {boolean | null | undefined} [singleTilde=true]\r\n *   Whether to support strikethrough with a single tilde (default: `true`).\r\n *\r\n *   Single tildes work on github.com, but are technically prohibited by the\r\n *   GFM spec.\r\n */\n\nimport { ok as assert } from 'devlop';\nimport { splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\nimport { codes, constants, types } from 'micromark-util-symbol';\n\n/**\r\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\r\n *\r\n * @param {Options | null | undefined} [options={}]\r\n *   Configuration.\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions`, to\r\n *   enable GFM strikethrough syntax.\r\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {};\n  let single = options_.singleTilde;\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    text: {\n      [codes.tilde]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [codes.tilde]\n    }\n  };\n\n  /**\r\n   * Take events and resolve strikethrough.\r\n   *\r\n   * @type {Resolver}\r\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1;\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        let open = index;\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open &&\n          // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            };\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            };\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]];\n            const insideSpan = context.parser.constructs.insideSpan.null;\n            if (insideSpan) {\n              // Between.\n              splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan, events.slice(open + 1, index), context));\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            splice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = types.data;\n      }\n    }\n    return events;\n  }\n\n  /**\r\n   * @this {TokenizeContext}\r\n   * @type {Tokenizer}\r\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous;\n    const events = this.events;\n    let size = 0;\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      assert(code === codes.tilde, 'expected `~`');\n      if (previous === codes.tilde && events[events.length - 1][1].type !== types.characterEscape) {\n        return nok(code);\n      }\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous);\n      if (code === codes.tilde) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n      if (size < 2 && !single) return nok(code);\n      const token = effects.exit('strikethroughSequenceTemporary');\n      const after = classifyCharacter(code);\n      token._open = !after || after === constants.attentionSideAfter && Boolean(before);\n      token._close = !before || before === constants.attentionSideAfter && Boolean(after);\n      return ok(code);\n    }\n  }\n}","map":{"version":3,"names":["ok","assert","splice","classifyCharacter","resolveAll","codes","constants","types","gfmStrikethrough","options","options_","single","singleTilde","tokenizer","tokenize","tokenizeStrikethrough","resolveAllStrikethrough","undefined","text","tilde","insideSpan","null","attentionMarkers","events","context","index","length","type","_close","open","_open","end","offset","start","strikethrough","Object","assign","nextEvents","parser","constructs","slice","data","effects","nok","previous","size","code","characterEscape","enter","more","before","consume","token","exit","after","attentionSideAfter","Boolean"],"sources":["C:/Users/rjalr/OneDrive/바탕 화면/ybigta/ybigta_blog_2/Ybigta-Blog/frontend/node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').Event} Event\r\n * @typedef {import('micromark-util-types').Extension} Extension\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n *\r\n * @typedef Options\r\n *   Configuration (optional).\r\n * @property {boolean | null | undefined} [singleTilde=true]\r\n *   Whether to support strikethrough with a single tilde (default: `true`).\r\n *\r\n *   Single tildes work on github.com, but are technically prohibited by the\r\n *   GFM spec.\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {splice} from 'micromark-util-chunked'\r\nimport {classifyCharacter} from 'micromark-util-classify-character'\r\nimport {resolveAll} from 'micromark-util-resolve-all'\r\nimport {codes, constants, types} from 'micromark-util-symbol'\r\n\r\n/**\r\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\r\n *\r\n * @param {Options | null | undefined} [options={}]\r\n *   Configuration.\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions`, to\r\n *   enable GFM strikethrough syntax.\r\n */\r\nexport function gfmStrikethrough(options) {\r\n  const options_ = options || {}\r\n  let single = options_.singleTilde\r\n  const tokenizer = {\r\n    tokenize: tokenizeStrikethrough,\r\n    resolveAll: resolveAllStrikethrough\r\n  }\r\n\r\n  if (single === null || single === undefined) {\r\n    single = true\r\n  }\r\n\r\n  return {\r\n    text: {[codes.tilde]: tokenizer},\r\n    insideSpan: {null: [tokenizer]},\r\n    attentionMarkers: {null: [codes.tilde]}\r\n  }\r\n\r\n  /**\r\n   * Take events and resolve strikethrough.\r\n   *\r\n   * @type {Resolver}\r\n   */\r\n  function resolveAllStrikethrough(events, context) {\r\n    let index = -1\r\n\r\n    // Walk through all events.\r\n    while (++index < events.length) {\r\n      // Find a token that can close.\r\n      if (\r\n        events[index][0] === 'enter' &&\r\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\r\n        events[index][1]._close\r\n      ) {\r\n        let open = index\r\n\r\n        // Now walk back to find an opener.\r\n        while (open--) {\r\n          // Find a token that can open the closer.\r\n          if (\r\n            events[open][0] === 'exit' &&\r\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\r\n            events[open][1]._open &&\r\n            // If the sizes are the same:\r\n            events[index][1].end.offset - events[index][1].start.offset ===\r\n              events[open][1].end.offset - events[open][1].start.offset\r\n          ) {\r\n            events[index][1].type = 'strikethroughSequence'\r\n            events[open][1].type = 'strikethroughSequence'\r\n\r\n            /** @type {Token} */\r\n            const strikethrough = {\r\n              type: 'strikethrough',\r\n              start: Object.assign({}, events[open][1].start),\r\n              end: Object.assign({}, events[index][1].end)\r\n            }\r\n\r\n            /** @type {Token} */\r\n            const text = {\r\n              type: 'strikethroughText',\r\n              start: Object.assign({}, events[open][1].end),\r\n              end: Object.assign({}, events[index][1].start)\r\n            }\r\n\r\n            // Opening.\r\n            /** @type {Array<Event>} */\r\n            const nextEvents = [\r\n              ['enter', strikethrough, context],\r\n              ['enter', events[open][1], context],\r\n              ['exit', events[open][1], context],\r\n              ['enter', text, context]\r\n            ]\r\n\r\n            const insideSpan = context.parser.constructs.insideSpan.null\r\n\r\n            if (insideSpan) {\r\n              // Between.\r\n              splice(\r\n                nextEvents,\r\n                nextEvents.length,\r\n                0,\r\n                resolveAll(insideSpan, events.slice(open + 1, index), context)\r\n              )\r\n            }\r\n\r\n            // Closing.\r\n            splice(nextEvents, nextEvents.length, 0, [\r\n              ['exit', text, context],\r\n              ['enter', events[index][1], context],\r\n              ['exit', events[index][1], context],\r\n              ['exit', strikethrough, context]\r\n            ])\r\n\r\n            splice(events, open - 1, index - open + 3, nextEvents)\r\n\r\n            index = open + nextEvents.length - 2\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    index = -1\r\n\r\n    while (++index < events.length) {\r\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\r\n        events[index][1].type = types.data\r\n      }\r\n    }\r\n\r\n    return events\r\n  }\r\n\r\n  /**\r\n   * @this {TokenizeContext}\r\n   * @type {Tokenizer}\r\n   */\r\n  function tokenizeStrikethrough(effects, ok, nok) {\r\n    const previous = this.previous\r\n    const events = this.events\r\n    let size = 0\r\n\r\n    return start\r\n\r\n    /** @type {State} */\r\n    function start(code) {\r\n      assert(code === codes.tilde, 'expected `~`')\r\n\r\n      if (\r\n        previous === codes.tilde &&\r\n        events[events.length - 1][1].type !== types.characterEscape\r\n      ) {\r\n        return nok(code)\r\n      }\r\n\r\n      effects.enter('strikethroughSequenceTemporary')\r\n      return more(code)\r\n    }\r\n\r\n    /** @type {State} */\r\n    function more(code) {\r\n      const before = classifyCharacter(previous)\r\n\r\n      if (code === codes.tilde) {\r\n        // If this is the third marker, exit.\r\n        if (size > 1) return nok(code)\r\n        effects.consume(code)\r\n        size++\r\n        return more\r\n      }\r\n\r\n      if (size < 2 && !single) return nok(code)\r\n      const token = effects.exit('strikethroughSequenceTemporary')\r\n      const after = classifyCharacter(code)\r\n      token._open =\r\n        !after || (after === constants.attentionSideAfter && Boolean(before))\r\n      token._close =\r\n        !before || (before === constants.attentionSideAfter && Boolean(after))\r\n      return ok(code)\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}