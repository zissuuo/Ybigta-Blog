{"ast":null,"code":"/**\r\n * @typedef {import('trough').Pipeline} Pipeline\r\n *\r\n * @typedef {import('unist').Node} Node\r\n *\r\n * @typedef {import('vfile').Compatible} Compatible\r\n * @typedef {import('vfile').Value} Value\r\n *\r\n * @typedef {import('../index.js').CompileResultMap} CompileResultMap\r\n * @typedef {import('../index.js').Data} Data\r\n * @typedef {import('../index.js').Settings} Settings\r\n */\n\n/**\r\n * @typedef {CompileResultMap[keyof CompileResultMap]} CompileResults\r\n *   Acceptable results from compilers.\r\n *\r\n *   To register custom results, add them to\r\n *   {@link CompileResultMap `CompileResultMap`}.\r\n */\n\n/**\r\n * @template {Node} [Tree=Node]\r\n *   The node that the compiler receives (default: `Node`).\r\n * @template {CompileResults} [Result=CompileResults]\r\n *   The thing that the compiler yields (default: `CompileResults`).\r\n * @callback Compiler\r\n *   A **compiler** handles the compiling of a syntax tree to something else\r\n *   (in most cases, text) (TypeScript type).\r\n *\r\n *   It is used in the stringify phase and called with a {@link Node `Node`}\r\n *   and {@link VFile `VFile`} representation of the document to compile.\r\n *   It should return the textual representation of the given tree (typically\r\n *   `string`).\r\n *\r\n *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most compilers\r\n *   > return `string` (or `Uint8Array`).\r\n *   > Some compilers, such as the one configured with\r\n *   > [`rehype-react`][rehype-react], return other values (in this case, a\r\n *   > React tree).\r\n *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\r\n *   > result values.\r\n *   >\r\n *   > To register custom results in TypeScript, add them to\r\n *   > {@link CompileResultMap `CompileResultMap`}.\r\n *\r\n *   [rehype-react]: https://github.com/rehypejs/rehype-react\r\n * @param {Tree} tree\r\n *   Tree to compile.\r\n * @param {VFile} file\r\n *   File associated with `tree`.\r\n * @returns {Result}\r\n *   New content: compiled text (`string` or `Uint8Array`, for `file.value`) or\r\n *   something else (for `file.result`).\r\n */\n\n/**\r\n * @template {Node} [Tree=Node]\r\n *   The node that the parser yields (default: `Node`)\r\n * @callback Parser\r\n *   A **parser** handles the parsing of text to a syntax tree.\r\n *\r\n *   It is used in the parse phase and is called with a `string` and\r\n *   {@link VFile `VFile`} of the document to parse.\r\n *   It must return the syntax tree representation of the given file\r\n *   ({@link Node `Node`}).\r\n * @param {string} document\r\n *   Document to parse.\r\n * @param {VFile} file\r\n *   File associated with `document`.\r\n * @returns {Tree}\r\n *   Node representing the given file.\r\n */\n\n/**\r\n * @typedef {(\r\n *   Plugin<Array<any>, any, any> |\r\n *   PluginTuple<Array<any>, any, any> |\r\n *   Preset\r\n * )} Pluggable\r\n *   Union of the different ways to add plugins and settings.\r\n */\n\n/**\r\n * @typedef {Array<Pluggable>} PluggableList\r\n *   List of plugins and presets.\r\n */\n\n// Note: we canâ€™t use `callback` yet as it messes up `this`:\n//  <https://github.com/microsoft/TypeScript/issues/55197>.\n/**\r\n * @template {Array<unknown>} [PluginParameters=[]]\r\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\r\n * @template {Node | string | undefined} [Input=Node]\r\n *   Value that is expected as input (default: `Node`).\r\n *\r\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\r\n *       should be the node it expects.\r\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be\r\n *       `string`.\r\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be the\r\n *       node it expects.\r\n * @template [Output=Input]\r\n *   Value that is yielded as output (default: `Input`).\r\n *\r\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\r\n *       should be the node that that yields.\r\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be the\r\n *       node that it yields.\r\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be\r\n *       result it yields.\r\n * @typedef {(\r\n *   (this: Processor, ...parameters: PluginParameters) =>\r\n *     Input extends string ? // Parser.\r\n *        Output extends Node | undefined ? undefined | void : never :\r\n *     Output extends CompileResults ? // Compiler.\r\n *        Input extends Node | undefined ? undefined | void : never :\r\n *     Transformer<\r\n *       Input extends Node ? Input : Node,\r\n *       Output extends Node ? Output : Node\r\n *     > | undefined | void\r\n * )} Plugin\r\n *   Single plugin.\r\n *\r\n *   Plugins configure the processors they are applied on in the following\r\n *   ways:\r\n *\r\n *   *   they change the processor, such as the parser, the compiler, or by\r\n *       configuring data\r\n *   *   they specify how to handle trees and files\r\n *\r\n *   In practice, they are functions that can receive options and configure the\r\n *   processor (`this`).\r\n *\r\n *   > ðŸ‘‰ **Note**: plugins are called when the processor is *frozen*, not when\r\n *   > they are applied.\r\n */\n\n/**\r\n * Tuple of a plugin and its configuration.\r\n *\r\n * The first item is a plugin, the rest are its parameters.\r\n *\r\n * @template {Array<unknown>} [TupleParameters=[]]\r\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\r\n * @template {Node | string | undefined} [Input=undefined]\r\n *   Value that is expected as input (optional).\r\n *\r\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\r\n *       should be the node it expects.\r\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be\r\n *       `string`.\r\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be the\r\n *       node it expects.\r\n * @template [Output=undefined] (optional).\r\n *   Value that is yielded as output.\r\n *\r\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\r\n *       should be the node that that yields.\r\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be the\r\n *       node that it yields.\r\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be\r\n *       result it yields.\r\n * @typedef {(\r\n *   [\r\n *     plugin: Plugin<TupleParameters, Input, Output>,\r\n *     ...parameters: TupleParameters\r\n *   ]\r\n * )} PluginTuple\r\n */\n\n/**\r\n * @typedef Preset\r\n *   Sharable configuration.\r\n *\r\n *   They can contain plugins and settings.\r\n * @property {PluggableList | undefined} [plugins]\r\n *   List of plugins and presets (optional).\r\n * @property {Settings | undefined} [settings]\r\n *   Shared settings for parsers and compilers (optional).\r\n */\n\n/**\r\n * @template {VFile} [File=VFile]\r\n *   The file that the callback receives (default: `VFile`).\r\n * @callback ProcessCallback\r\n *   Callback called when the process is done.\r\n *\r\n *   Called with either an error or a result.\r\n * @param {Error | undefined} [error]\r\n *   Fatal error (optional).\r\n * @param {File | undefined} [file]\r\n *   Processed file (optional).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\n\n/**\r\n * @template {Node} [Tree=Node]\r\n *   The tree that the callback receives (default: `Node`).\r\n * @callback RunCallback\r\n *   Callback called when transformers are done.\r\n *\r\n *   Called with either an error or results.\r\n * @param {Error | undefined} [error]\r\n *   Fatal error (optional).\r\n * @param {Tree | undefined} [tree]\r\n *   Transformed tree (optional).\r\n * @param {VFile | undefined} [file]\r\n *   File (optional).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\n\n/**\r\n * @template {Node} [Output=Node]\r\n *   Node type that the transformer yields (default: `Node`).\r\n * @callback TransformCallback\r\n *   Callback passed to transforms.\r\n *\r\n *   If the signature of a `transformer` accepts a third argument, the\r\n *   transformer may perform asynchronous operations, and must call it.\r\n * @param {Error | undefined} [error]\r\n *   Fatal error to stop the process (optional).\r\n * @param {Output | undefined} [tree]\r\n *   New, changed, tree (optional).\r\n * @param {VFile | undefined} [file]\r\n *   New, changed, file (optional).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\n\n/**\r\n * @template {Node} [Input=Node]\r\n *   Node type that the transformer expects (default: `Node`).\r\n * @template {Node} [Output=Input]\r\n *   Node type that the transformer yields (default: `Input`).\r\n * @callback Transformer\r\n *   Transformers handle syntax trees and files.\r\n *\r\n *   They are functions that are called each time a syntax tree and file are\r\n *   passed through the run phase.\r\n *   When an error occurs in them (either because itâ€™s thrown, returned,\r\n *   rejected, or passed to `next`), the process stops.\r\n *\r\n *   The run phase is handled by [`trough`][trough], see its documentation for\r\n *   the exact semantics of these functions.\r\n *\r\n *   > ðŸ‘‰ **Note**: you should likely ignore `next`: donâ€™t accept it.\r\n *   > it supports callback-style async work.\r\n *   > But promises are likely easier to reason about.\r\n *\r\n *   [trough]: https://github.com/wooorm/trough#function-fninput-next\r\n * @param {Input} tree\r\n *   Tree to handle.\r\n * @param {VFile} file\r\n *   File to handle.\r\n * @param {TransformCallback<Output>} next\r\n *   Callback.\r\n * @returns {(\r\n *   Promise<Output | undefined | void> |\r\n *   Promise<never> | // For some reason this is needed separately.\r\n *   Output |\r\n *   Error |\r\n *   undefined |\r\n *   void\r\n * )}\r\n *   If you accept `next`, nothing.\r\n *   Otherwise:\r\n *\r\n *   *   `Error` â€” fatal error to stop the process\r\n *   *   `Promise<undefined>` or `undefined` â€” the next transformer keeps using\r\n *       same tree\r\n *   *   `Promise<Node>` or `Node` â€” new, changed, tree\r\n */\n\n/**\r\n * @template {Node | undefined} ParseTree\r\n *   Output of `parse`.\r\n * @template {Node | undefined} HeadTree\r\n *   Input for `run`.\r\n * @template {Node | undefined} TailTree\r\n *   Output for `run`.\r\n * @template {Node | undefined} CompileTree\r\n *   Input of `stringify`.\r\n * @template {CompileResults | undefined} CompileResult\r\n *   Output of `stringify`.\r\n * @template {Node | string | undefined} Input\r\n *   Input of plugin.\r\n * @template Output\r\n *   Output of plugin (optional).\r\n * @typedef {(\r\n *   Input extends string\r\n *     ? Output extends Node | undefined\r\n *       ? // Parser.\r\n *         Processor<\r\n *           Output extends undefined ? ParseTree : Output,\r\n *           HeadTree,\r\n *           TailTree,\r\n *           CompileTree,\r\n *           CompileResult\r\n *         >\r\n *       : // Unknown.\r\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\r\n *     : Output extends CompileResults\r\n *     ? Input extends Node | undefined\r\n *       ? // Compiler.\r\n *         Processor<\r\n *           ParseTree,\r\n *           HeadTree,\r\n *           TailTree,\r\n *           Input extends undefined ? CompileTree : Input,\r\n *           Output extends undefined ? CompileResult : Output\r\n *         >\r\n *       : // Unknown.\r\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\r\n *     : Input extends Node | undefined\r\n *     ? Output extends Node | undefined\r\n *       ? // Transform.\r\n *         Processor<\r\n *           ParseTree,\r\n *           HeadTree extends undefined ? Input : HeadTree,\r\n *           Output extends undefined ? TailTree : Output,\r\n *           CompileTree,\r\n *           CompileResult\r\n *         >\r\n *       : // Unknown.\r\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\r\n *     : // Unknown.\r\n *       Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\r\n * )} UsePlugin\r\n *   Create a processor based on the input/output of a {@link Plugin plugin}.\r\n */\n\n/**\r\n * @template {CompileResults | undefined} Result\r\n *   Node type that the transformer yields.\r\n * @typedef {(\r\n *   Result extends Value | undefined ?\r\n *     VFile :\r\n *     VFile & {result: Result}\r\n *   )} VFileWithOutput\r\n *   Type to generate a {@link VFile `VFile`} corresponding to a compiler result.\r\n *\r\n *   If a result that is not acceptable on a `VFile` is used, that will\r\n *   be stored on the `result` field of {@link VFile `VFile`}.\r\n */\n\nimport { bail } from 'bail';\nimport extend from 'extend';\nimport { ok as assert } from 'devlop';\nimport isPlainObj from 'is-plain-obj';\nimport { trough } from 'trough';\nimport { VFile } from 'vfile';\nimport { CallableInstance } from './callable-instance.js';\n\n// To do: next major: drop `Compiler`, `Parser`: prefer lowercase.\n\n// To do: we could start yielding `never` in TS when a parser is missing and\n// `parse` is called.\n// Currently, we allow directly setting `processor.parser`, which is untyped.\n\nconst own = {}.hasOwnProperty;\n\n/**\r\n * @template {Node | undefined} [ParseTree=undefined]\r\n *   Output of `parse` (optional).\r\n * @template {Node | undefined} [HeadTree=undefined]\r\n *   Input for `run` (optional).\r\n * @template {Node | undefined} [TailTree=undefined]\r\n *   Output for `run` (optional).\r\n * @template {Node | undefined} [CompileTree=undefined]\r\n *   Input of `stringify` (optional).\r\n * @template {CompileResults | undefined} [CompileResult=undefined]\r\n *   Output of `stringify` (optional).\r\n * @extends {CallableInstance<[], Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>>}\r\n */\nexport class Processor extends CallableInstance {\n  /**\r\n   * Create a processor.\r\n   */\n  constructor() {\n    // If `Processor()` is called (w/o new), `copy` is called instead.\n    super('copy');\n\n    /**\r\n     * Compiler to use (deprecated).\r\n     *\r\n     * @deprecated\r\n     *   Use `compiler` instead.\r\n     * @type {(\r\n     *   Compiler<\r\n     *     CompileTree extends undefined ? Node : CompileTree,\r\n     *     CompileResult extends undefined ? CompileResults : CompileResult\r\n     *   > |\r\n     *   undefined\r\n     * )}\r\n     */\n    this.Compiler = undefined;\n\n    /**\r\n     * Parser to use (deprecated).\r\n     *\r\n     * @deprecated\r\n     *   Use `parser` instead.\r\n     * @type {(\r\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\r\n     *   undefined\r\n     * )}\r\n     */\n    this.Parser = undefined;\n\n    // Note: the following fields are considered private.\n    // However, they are needed for tests, and TSC generates an untyped\n    // `private freezeIndex` field for, which trips `type-coverage` up.\n    // Instead, we use `@deprecated` to visualize that they shouldnâ€™t be used.\n    /**\r\n     * Internal list of configured plugins.\r\n     *\r\n     * @deprecated\r\n     *   This is a private internal property and should not be used.\r\n     * @type {Array<PluginTuple<Array<unknown>>>}\r\n     */\n    this.attachers = [];\n\n    /**\r\n     * Compiler to use.\r\n     *\r\n     * @type {(\r\n     *   Compiler<\r\n     *     CompileTree extends undefined ? Node : CompileTree,\r\n     *     CompileResult extends undefined ? CompileResults : CompileResult\r\n     *   > |\r\n     *   undefined\r\n     * )}\r\n     */\n    this.compiler = undefined;\n\n    /**\r\n     * Internal state to track where we are while freezing.\r\n     *\r\n     * @deprecated\r\n     *   This is a private internal property and should not be used.\r\n     * @type {number}\r\n     */\n    this.freezeIndex = -1;\n\n    /**\r\n     * Internal state to track whether weâ€™re frozen.\r\n     *\r\n     * @deprecated\r\n     *   This is a private internal property and should not be used.\r\n     * @type {boolean | undefined}\r\n     */\n    this.frozen = undefined;\n\n    /**\r\n     * Internal state.\r\n     *\r\n     * @deprecated\r\n     *   This is a private internal property and should not be used.\r\n     * @type {Data}\r\n     */\n    this.namespace = {};\n\n    /**\r\n     * Parser to use.\r\n     *\r\n     * @type {(\r\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\r\n     *   undefined\r\n     * )}\r\n     */\n    this.parser = undefined;\n\n    /**\r\n     * Internal list of configured transformers.\r\n     *\r\n     * @deprecated\r\n     *   This is a private internal property and should not be used.\r\n     * @type {Pipeline}\r\n     */\n    this.transformers = trough();\n  }\n\n  /**\r\n   * Copy a processor.\r\n   *\r\n   * @deprecated\r\n   *   This is a private internal method and should not be used.\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *   New *unfrozen* processor ({@link Processor `Processor`}) that is\r\n   *   configured to work the same as its ancestor.\r\n   *   When the descendant processor is configured in the future it does not\r\n   *   affect the ancestral processor.\r\n   */\n  copy() {\n    // Cast as the type parameters will be the same after attaching.\n    const destination = /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */\n    new Processor();\n    let index = -1;\n    while (++index < this.attachers.length) {\n      const attacher = this.attachers[index];\n      destination.use(...attacher);\n    }\n    destination.data(extend(true, {}, this.namespace));\n    return destination;\n  }\n\n  /**\r\n   * Configure the processor with info available to all plugins.\r\n   * Information is stored in an object.\r\n   *\r\n   * Typically, options can be given to a specific plugin, but sometimes it\r\n   * makes sense to have information shared with several plugins.\r\n   * For example, a list of HTML elements that are self-closing, which is\r\n   * needed during all phases.\r\n   *\r\n   * > ðŸ‘‰ **Note**: setting information cannot occur on *frozen* processors.\r\n   * > Call the processor first to create a new unfrozen processor.\r\n   *\r\n   * > ðŸ‘‰ **Note**: to register custom data in TypeScript, augment the\r\n   * > {@link Data `Data`} interface.\r\n   *\r\n   * @example\r\n   *   This example show how to get and set info:\r\n   *\r\n   *   ```js\r\n   *   import {unified} from 'unified'\r\n   *\r\n   *   const processor = unified().data('alpha', 'bravo')\r\n   *\r\n   *   processor.data('alpha') // => 'bravo'\r\n   *\r\n   *   processor.data() // => {alpha: 'bravo'}\r\n   *\r\n   *   processor.data({charlie: 'delta'})\r\n   *\r\n   *   processor.data() // => {charlie: 'delta'}\r\n   *   ```\r\n   *\r\n   * @template {keyof Data} Key\r\n   *\r\n   * @overload\r\n   * @returns {Data}\r\n   *\r\n   * @overload\r\n   * @param {Data} dataset\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *\r\n   * @overload\r\n   * @param {Key} key\r\n   * @returns {Data[Key]}\r\n   *\r\n   * @overload\r\n   * @param {Key} key\r\n   * @param {Data[Key]} value\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *\r\n   * @param {Data | Key} [key]\r\n   *   Key to get or set, or entire dataset to set, or nothing to get the\r\n   *   entire dataset (optional).\r\n   * @param {Data[Key]} [value]\r\n   *   Value to set (optional).\r\n   * @returns {unknown}\r\n   *   The current processor when setting, the value at `key` when getting, or\r\n   *   the entire dataset when getting without key.\r\n   */\n  data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', this.frozen);\n        this.namespace[key] = value;\n        return this;\n      }\n\n      // Get `key`.\n      return own.call(this.namespace, key) && this.namespace[key] || undefined;\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', this.frozen);\n      this.namespace = key;\n      return this;\n    }\n\n    // Get space.\n    return this.namespace;\n  }\n\n  /**\r\n   * Freeze a processor.\r\n   *\r\n   * Frozen processors are meant to be extended and not to be configured\r\n   * directly.\r\n   *\r\n   * When a processor is frozen it cannot be unfrozen.\r\n   * New processors working the same way can be created by calling the\r\n   * processor.\r\n   *\r\n   * Itâ€™s possible to freeze processors explicitly by calling `.freeze()`.\r\n   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,\r\n   * `.stringify()`, `.process()`, or `.processSync()` are called.\r\n   *\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *   The current processor.\r\n   */\n  freeze() {\n    if (this.frozen) {\n      return this;\n    }\n\n    // Cast so that we can type plugins easier.\n    // Plugins are supposed to be usable on different processors, not just on\n    // this exact processor.\n    const self = /** @type {Processor} */ /** @type {unknown} */this;\n    while (++this.freezeIndex < this.attachers.length) {\n      const [attacher, ...options] = this.attachers[this.freezeIndex];\n      if (options[0] === false) {\n        continue;\n      }\n      if (options[0] === true) {\n        options[0] = undefined;\n      }\n      const transformer = attacher.call(self, ...options);\n      if (typeof transformer === 'function') {\n        this.transformers.use(transformer);\n      }\n    }\n    this.frozen = true;\n    this.freezeIndex = Number.POSITIVE_INFINITY;\n    return this;\n  }\n\n  /**\r\n   * Parse text to a syntax tree.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `parse` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `parse` performs the parse phase, not the run phase or other\r\n   * > phases.\r\n   *\r\n   * @param {Compatible | undefined} [file]\r\n   *   file to parse (optional); typically `string` or `VFile`; any value\r\n   *   accepted as `x` in `new VFile(x)`.\r\n   * @returns {ParseTree extends undefined ? Node : ParseTree}\r\n   *   Syntax tree representing `file`.\r\n   */\n  parse(file) {\n    this.freeze();\n    const realFile = vfile(file);\n    const parser = this.parser || this.Parser;\n    assertParser('parse', parser);\n    return parser(String(realFile), realFile);\n  }\n\n  /**\r\n   * Process the given file as configured on the processor.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `process` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `process` performs the parse, run, and stringify phases.\r\n   *\r\n   * @overload\r\n   * @param {Compatible | undefined} file\r\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done\r\n   * @returns {undefined}\r\n   *\r\n   * @overload\r\n   * @param {Compatible | undefined} [file]\r\n   * @returns {Promise<VFileWithOutput<CompileResult>>}\r\n   *\r\n   * @param {Compatible | undefined} [file]\r\n   *   File (optional); typically `string` or `VFile`]; any value accepted as\r\n   *   `x` in `new VFile(x)`.\r\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]\r\n   *   Callback (optional).\r\n   * @returns {Promise<VFile> | undefined}\r\n   *   Nothing if `done` is given.\r\n   *   Otherwise a promise, rejected with a fatal error or resolved with the\r\n   *   processed file.\r\n   *\r\n   *   The parsed, transformed, and compiled value is available at\r\n   *   `file.value` (see note).\r\n   *\r\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most\r\n   *   > compilers return `string` (or `Uint8Array`).\r\n   *   > Some compilers, such as the one configured with\r\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\r\n   *   > React tree).\r\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\r\n   *   > result values.\r\n   *   >\r\n   *   > To register custom results in TypeScript, add them to\r\n   *   > {@link CompileResultMap `CompileResultMap`}.\r\n   *\r\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\r\n   */\n  process(file, done) {\n    const self = this;\n    this.freeze();\n    assertParser('process', this.parser || this.Parser);\n    assertCompiler('process', this.compiler || this.Compiler);\n    return done ? executor(undefined, done) : new Promise(executor);\n\n    // Note: `void`s needed for TS.\n    /**\r\n     * @param {((file: VFileWithOutput<CompileResult>) => undefined | void) | undefined} resolve\r\n     * @param {(error: Error | undefined) => undefined | void} reject\r\n     * @returns {undefined}\r\n     */\n    function executor(resolve, reject) {\n      const realFile = vfile(file);\n      // Assume `ParseTree` (the result of the parser) matches `HeadTree` (the\n      // input of the first transform).\n      const parseTree = /** @type {HeadTree extends undefined ? Node : HeadTree} */\n      /** @type {unknown} */self.parse(realFile);\n      self.run(parseTree, realFile, function (error, tree, file) {\n        if (error || !tree || !file) {\n          return realDone(error);\n        }\n\n        // Assume `TailTree` (the output of the last transform) matches\n        // `CompileTree` (the input of the compiler).\n        const compileTree = /** @type {CompileTree extends undefined ? Node : CompileTree} */\n        /** @type {unknown} */tree;\n        const compileResult = self.stringify(compileTree, file);\n        if (looksLikeAValue(compileResult)) {\n          file.value = compileResult;\n        } else {\n          file.result = compileResult;\n        }\n        realDone(error, /** @type {VFileWithOutput<CompileResult>} */file);\n      });\n\n      /**\r\n       * @param {Error | undefined} error\r\n       * @param {VFileWithOutput<CompileResult> | undefined} [file]\r\n       * @returns {undefined}\r\n       */\n      function realDone(error, file) {\n        if (error || !file) {\n          reject(error);\n        } else if (resolve) {\n          resolve(file);\n        } else {\n          assert(done, '`done` is defined if `resolve` is not');\n          done(undefined, file);\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Process the given file as configured on the processor.\r\n   *\r\n   * An error is thrown if asynchronous transforms are configured.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `processSync` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `processSync` performs the parse, run, and stringify phases.\r\n   *\r\n   * @param {Compatible | undefined} [file]\r\n   *   File (optional); typically `string` or `VFile`; any value accepted as\r\n   *   `x` in `new VFile(x)`.\r\n   * @returns {VFileWithOutput<CompileResult>}\r\n   *   The processed file.\r\n   *\r\n   *   The parsed, transformed, and compiled value is available at\r\n   *   `file.value` (see note).\r\n   *\r\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most\r\n   *   > compilers return `string` (or `Uint8Array`).\r\n   *   > Some compilers, such as the one configured with\r\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\r\n   *   > React tree).\r\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\r\n   *   > result values.\r\n   *   >\r\n   *   > To register custom results in TypeScript, add them to\r\n   *   > {@link CompileResultMap `CompileResultMap`}.\r\n   *\r\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\r\n   */\n  processSync(file) {\n    /** @type {boolean} */\n    let complete = false;\n    /** @type {VFileWithOutput<CompileResult> | undefined} */\n    let result;\n    this.freeze();\n    assertParser('processSync', this.parser || this.Parser);\n    assertCompiler('processSync', this.compiler || this.Compiler);\n    this.process(file, realDone);\n    assertDone('processSync', 'process', complete);\n    assert(result, 'we either bailed on an error or have a tree');\n    return result;\n\n    /**\r\n     * @type {ProcessCallback<VFileWithOutput<CompileResult>>}\r\n     */\n    function realDone(error, file) {\n      complete = true;\n      bail(error);\n      result = file;\n    }\n  }\n\n  /**\r\n   * Run *transformers* on a syntax tree.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `run` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `run` performs the run phase, not other phases.\r\n   *\r\n   * @overload\r\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\r\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\r\n   * @returns {undefined}\r\n   *\r\n   * @overload\r\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\r\n   * @param {Compatible | undefined} file\r\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\r\n   * @returns {undefined}\r\n   *\r\n   * @overload\r\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\r\n   * @param {Compatible | undefined} [file]\r\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}\r\n   *\r\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\r\n   *   Tree to transform and inspect.\r\n   * @param {(\r\n   *   RunCallback<TailTree extends undefined ? Node : TailTree> |\r\n   *   Compatible\r\n   * )} [file]\r\n   *   File associated with `node` (optional); any value accepted as `x` in\r\n   *   `new VFile(x)`.\r\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]\r\n   *   Callback (optional).\r\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}\r\n   *   Nothing if `done` is given.\r\n   *   Otherwise, a promise rejected with a fatal error or resolved with the\r\n   *   transformed tree.\r\n   */\n  run(tree, file, done) {\n    assertNode(tree);\n    this.freeze();\n    const transformers = this.transformers;\n    if (!done && typeof file === 'function') {\n      done = file;\n      file = undefined;\n    }\n    return done ? executor(undefined, done) : new Promise(executor);\n\n    // Note: `void`s needed for TS.\n    /**\r\n     * @param {(\r\n     *   ((tree: TailTree extends undefined ? Node : TailTree) => undefined | void) |\r\n     *   undefined\r\n     * )} resolve\r\n     * @param {(error: Error) => undefined | void} reject\r\n     * @returns {undefined}\r\n     */\n    function executor(resolve, reject) {\n      assert(typeof file !== 'function', '`file` canâ€™t be a `done` anymore, we checked');\n      const realFile = vfile(file);\n      transformers.run(tree, realFile, realDone);\n\n      /**\r\n       * @param {Error | undefined} error\r\n       * @param {Node} outputTree\r\n       * @param {VFile} file\r\n       * @returns {undefined}\r\n       */\n      function realDone(error, outputTree, file) {\n        const resultingTree = /** @type {TailTree extends undefined ? Node : TailTree} */\n        outputTree || tree;\n        if (error) {\n          reject(error);\n        } else if (resolve) {\n          resolve(resultingTree);\n        } else {\n          assert(done, '`done` is defined if `resolve` is not');\n          done(undefined, resultingTree, file);\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Run *transformers* on a syntax tree.\r\n   *\r\n   * An error is thrown if asynchronous transforms are configured.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `runSync` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `runSync` performs the run phase, not other phases.\r\n   *\r\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\r\n   *   Tree to transform and inspect.\r\n   * @param {Compatible | undefined} [file]\r\n   *   File associated with `node` (optional); any value accepted as `x` in\r\n   *   `new VFile(x)`.\r\n   * @returns {TailTree extends undefined ? Node : TailTree}\r\n   *   Transformed tree.\r\n   */\n  runSync(tree, file) {\n    /** @type {boolean} */\n    let complete = false;\n    /** @type {(TailTree extends undefined ? Node : TailTree) | undefined} */\n    let result;\n    this.run(tree, file, realDone);\n    assertDone('runSync', 'run', complete);\n    assert(result, 'we either bailed on an error or have a tree');\n    return result;\n\n    /**\r\n     * @type {RunCallback<TailTree extends undefined ? Node : TailTree>}\r\n     */\n    function realDone(error, tree) {\n      bail(error);\n      result = tree;\n      complete = true;\n    }\n  }\n\n  /**\r\n   * Compile a syntax tree.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `stringify` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `stringify` performs the stringify phase, not the run phase\r\n   * > or other phases.\r\n   *\r\n   * @param {CompileTree extends undefined ? Node : CompileTree} tree\r\n   *   Tree to compile.\r\n   * @param {Compatible | undefined} [file]\r\n   *   File associated with `node` (optional); any value accepted as `x` in\r\n   *   `new VFile(x)`.\r\n   * @returns {CompileResult extends undefined ? Value : CompileResult}\r\n   *   Textual representation of the tree (see note).\r\n   *\r\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most compilers\r\n   *   > return `string` (or `Uint8Array`).\r\n   *   > Some compilers, such as the one configured with\r\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\r\n   *   > React tree).\r\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\r\n   *   > result values.\r\n   *   >\r\n   *   > To register custom results in TypeScript, add them to\r\n   *   > {@link CompileResultMap `CompileResultMap`}.\r\n   *\r\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\r\n   */\n  stringify(tree, file) {\n    this.freeze();\n    const realFile = vfile(file);\n    const compiler = this.compiler || this.Compiler;\n    assertCompiler('stringify', compiler);\n    assertNode(tree);\n    return compiler(tree, realFile);\n  }\n\n  /**\r\n   * Configure the processor to use a plugin, a list of usable values, or a\r\n   * preset.\r\n   *\r\n   * If the processor is already using a plugin, the previous plugin\r\n   * configuration is changed based on the options that are passed in.\r\n   * In other words, the plugin is not added a second time.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `use` cannot be called on *frozen* processors.\r\n   * > Call the processor first to create a new unfrozen processor.\r\n   *\r\n   * @example\r\n   *   There are many ways to pass plugins to `.use()`.\r\n   *   This example gives an overview:\r\n   *\r\n   *   ```js\r\n   *   import {unified} from 'unified'\r\n   *\r\n   *   unified()\r\n   *     // Plugin with options:\r\n   *     .use(pluginA, {x: true, y: true})\r\n   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\r\n   *     .use(pluginA, {y: false, z: true})\r\n   *     // Plugins:\r\n   *     .use([pluginB, pluginC])\r\n   *     // Two plugins, the second with options:\r\n   *     .use([pluginD, [pluginE, {}]])\r\n   *     // Preset with plugins and settings:\r\n   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\r\n   *     // Settings only:\r\n   *     .use({settings: {position: false}})\r\n   *   ```\r\n   *\r\n   * @template {Array<unknown>} [Parameters=[]]\r\n   * @template {Node | string | undefined} [Input=undefined]\r\n   * @template [Output=Input]\r\n   *\r\n   * @overload\r\n   * @param {Preset | null | undefined} [preset]\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *\r\n   * @overload\r\n   * @param {PluggableList} list\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *\r\n   * @overload\r\n   * @param {Plugin<Parameters, Input, Output>} plugin\r\n   * @param {...(Parameters | [boolean])} parameters\r\n   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}\r\n   *\r\n   * @param {PluggableList | Plugin | Preset | null | undefined} value\r\n   *   Usable value.\r\n   * @param {...unknown} parameters\r\n   *   Parameters, when a plugin is given as a usable value.\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *   Current processor.\r\n   */\n  use(value, ...parameters) {\n    const attachers = this.attachers;\n    const namespace = this.namespace;\n    assertUnfrozen('use', this.frozen);\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, parameters);\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value);\n      } else {\n        addPreset(value);\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`');\n    }\n    return this;\n\n    /**\r\n     * @param {Pluggable} value\r\n     * @returns {undefined}\r\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value, []);\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...parameters] = /** @type {PluginTuple<Array<unknown>>} */value;\n          addPlugin(plugin, parameters);\n        } else {\n          addPreset(value);\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`');\n      }\n    }\n\n    /**\r\n     * @param {Preset} result\r\n     * @returns {undefined}\r\n     */\n    function addPreset(result) {\n      if (!('plugins' in result) && !('settings' in result)) {\n        throw new Error('Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither');\n      }\n      addList(result.plugins);\n      if (result.settings) {\n        namespace.settings = extend(true, namespace.settings, result.settings);\n      }\n    }\n\n    /**\r\n     * @param {PluggableList | null | undefined} plugins\r\n     * @returns {undefined}\r\n     */\n    function addList(plugins) {\n      let index = -1;\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index];\n          add(thing);\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`');\n      }\n    }\n\n    /**\r\n     * @param {Plugin} plugin\r\n     * @param {Array<unknown>} parameters\r\n     * @returns {undefined}\r\n     */\n    function addPlugin(plugin, parameters) {\n      let index = -1;\n      let entryIndex = -1;\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entryIndex = index;\n          break;\n        }\n      }\n      if (entryIndex === -1) {\n        attachers.push([plugin, ...parameters]);\n      }\n      // Only set if there was at least a `primary` value, otherwise weâ€™d change\n      // `arguments.length`.\n      else if (parameters.length > 0) {\n        let [primary, ...rest] = parameters;\n        const currentPrimary = attachers[entryIndex][1];\n        if (isPlainObj(currentPrimary) && isPlainObj(primary)) {\n          primary = extend(true, currentPrimary, primary);\n        }\n        attachers[entryIndex] = [plugin, primary, ...rest];\n      }\n    }\n  }\n}\n\n// Note: this returns a *callable* instance.\n// Thatâ€™s why itâ€™s documented as a function.\n/**\r\n * Create a new processor.\r\n *\r\n * @example\r\n *   This example shows how a new processor can be created (from `remark`) and linked\r\n *   to **stdin**(4) and **stdout**(4).\r\n *\r\n *   ```js\r\n *   import process from 'node:process'\r\n *   import concatStream from 'concat-stream'\r\n *   import {remark} from 'remark'\r\n *\r\n *   process.stdin.pipe(\r\n *     concatStream(function (buf) {\r\n *       process.stdout.write(String(remark().processSync(buf)))\r\n *     })\r\n *   )\r\n *   ```\r\n *\r\n * @returns\r\n *   New *unfrozen* processor (`processor`).\r\n *\r\n *   This processor is configured to work the same as its ancestor.\r\n *   When the descendant processor is configured in the future it does not\r\n *   affect the ancestral processor.\r\n */\nexport const unified = new Processor().freeze();\n\n/**\r\n * Assert a parser is available.\r\n *\r\n * @param {string} name\r\n * @param {unknown} value\r\n * @returns {asserts value is Parser}\r\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `parser`');\n  }\n}\n\n/**\r\n * Assert a compiler is available.\r\n *\r\n * @param {string} name\r\n * @param {unknown} value\r\n * @returns {asserts value is Compiler}\r\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `compiler`');\n  }\n}\n\n/**\r\n * Assert the processor is not frozen.\r\n *\r\n * @param {string} name\r\n * @param {unknown} frozen\r\n * @returns {asserts frozen is false}\r\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error('Cannot call `' + name + '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.');\n  }\n}\n\n/**\r\n * Assert `node` is a unist node.\r\n *\r\n * @param {unknown} node\r\n * @returns {asserts node is Node}\r\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`');\n    // Fine.\n  }\n}\n\n/**\r\n * Assert that `complete` is `true`.\r\n *\r\n * @param {string} name\r\n * @param {string} asyncName\r\n * @param {unknown} complete\r\n * @returns {asserts complete is true}\r\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\n  }\n}\n\n/**\r\n * @param {Compatible | undefined} [value]\r\n * @returns {VFile}\r\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value);\n}\n\n/**\r\n * @param {Compatible | undefined} [value]\r\n * @returns {value is VFile}\r\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(value && typeof value === 'object' && 'message' in value && 'messages' in value);\n}\n\n/**\r\n * @param {unknown} [value]\r\n * @returns {value is Value}\r\n */\nfunction looksLikeAValue(value) {\n  return typeof value === 'string' || isUint8Array(value);\n}\n\n/**\r\n * Assert `value` is an `Uint8Array`.\r\n *\r\n * @param {unknown} value\r\n *   thing.\r\n * @returns {value is Uint8Array}\r\n *   Whether `value` is an `Uint8Array`.\r\n */\nfunction isUint8Array(value) {\n  return Boolean(value && typeof value === 'object' && 'byteLength' in value && 'byteOffset' in value);\n}","map":{"version":3,"names":["bail","extend","ok","assert","isPlainObj","trough","VFile","CallableInstance","own","hasOwnProperty","Processor","constructor","Compiler","undefined","Parser","attachers","compiler","freezeIndex","frozen","namespace","parser","transformers","copy","destination","index","length","attacher","use","data","key","value","arguments","assertUnfrozen","call","freeze","self","options","transformer","Number","POSITIVE_INFINITY","parse","file","realFile","vfile","assertParser","String","process","done","assertCompiler","executor","Promise","resolve","reject","parseTree","run","error","tree","realDone","compileTree","compileResult","stringify","looksLikeAValue","result","processSync","complete","assertDone","assertNode","outputTree","resultingTree","runSync","parameters","addPlugin","Array","isArray","addList","addPreset","TypeError","add","plugin","Error","plugins","settings","thing","entryIndex","push","primary","rest","currentPrimary","unified","name","node","type","asyncName","looksLikeAVFile","Boolean","isUint8Array"],"sources":["E:/Documents/2024-1 YBIGTA/Ybigta_BLOG/Ybigta-Blog/frontend/node_modules/unified/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('trough').Pipeline} Pipeline\r\n *\r\n * @typedef {import('unist').Node} Node\r\n *\r\n * @typedef {import('vfile').Compatible} Compatible\r\n * @typedef {import('vfile').Value} Value\r\n *\r\n * @typedef {import('../index.js').CompileResultMap} CompileResultMap\r\n * @typedef {import('../index.js').Data} Data\r\n * @typedef {import('../index.js').Settings} Settings\r\n */\r\n\r\n/**\r\n * @typedef {CompileResultMap[keyof CompileResultMap]} CompileResults\r\n *   Acceptable results from compilers.\r\n *\r\n *   To register custom results, add them to\r\n *   {@link CompileResultMap `CompileResultMap`}.\r\n */\r\n\r\n/**\r\n * @template {Node} [Tree=Node]\r\n *   The node that the compiler receives (default: `Node`).\r\n * @template {CompileResults} [Result=CompileResults]\r\n *   The thing that the compiler yields (default: `CompileResults`).\r\n * @callback Compiler\r\n *   A **compiler** handles the compiling of a syntax tree to something else\r\n *   (in most cases, text) (TypeScript type).\r\n *\r\n *   It is used in the stringify phase and called with a {@link Node `Node`}\r\n *   and {@link VFile `VFile`} representation of the document to compile.\r\n *   It should return the textual representation of the given tree (typically\r\n *   `string`).\r\n *\r\n *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most compilers\r\n *   > return `string` (or `Uint8Array`).\r\n *   > Some compilers, such as the one configured with\r\n *   > [`rehype-react`][rehype-react], return other values (in this case, a\r\n *   > React tree).\r\n *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\r\n *   > result values.\r\n *   >\r\n *   > To register custom results in TypeScript, add them to\r\n *   > {@link CompileResultMap `CompileResultMap`}.\r\n *\r\n *   [rehype-react]: https://github.com/rehypejs/rehype-react\r\n * @param {Tree} tree\r\n *   Tree to compile.\r\n * @param {VFile} file\r\n *   File associated with `tree`.\r\n * @returns {Result}\r\n *   New content: compiled text (`string` or `Uint8Array`, for `file.value`) or\r\n *   something else (for `file.result`).\r\n */\r\n\r\n/**\r\n * @template {Node} [Tree=Node]\r\n *   The node that the parser yields (default: `Node`)\r\n * @callback Parser\r\n *   A **parser** handles the parsing of text to a syntax tree.\r\n *\r\n *   It is used in the parse phase and is called with a `string` and\r\n *   {@link VFile `VFile`} of the document to parse.\r\n *   It must return the syntax tree representation of the given file\r\n *   ({@link Node `Node`}).\r\n * @param {string} document\r\n *   Document to parse.\r\n * @param {VFile} file\r\n *   File associated with `document`.\r\n * @returns {Tree}\r\n *   Node representing the given file.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Plugin<Array<any>, any, any> |\r\n *   PluginTuple<Array<any>, any, any> |\r\n *   Preset\r\n * )} Pluggable\r\n *   Union of the different ways to add plugins and settings.\r\n */\r\n\r\n/**\r\n * @typedef {Array<Pluggable>} PluggableList\r\n *   List of plugins and presets.\r\n */\r\n\r\n// Note: we canâ€™t use `callback` yet as it messes up `this`:\r\n//  <https://github.com/microsoft/TypeScript/issues/55197>.\r\n/**\r\n * @template {Array<unknown>} [PluginParameters=[]]\r\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\r\n * @template {Node | string | undefined} [Input=Node]\r\n *   Value that is expected as input (default: `Node`).\r\n *\r\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\r\n *       should be the node it expects.\r\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be\r\n *       `string`.\r\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be the\r\n *       node it expects.\r\n * @template [Output=Input]\r\n *   Value that is yielded as output (default: `Input`).\r\n *\r\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\r\n *       should be the node that that yields.\r\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be the\r\n *       node that it yields.\r\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be\r\n *       result it yields.\r\n * @typedef {(\r\n *   (this: Processor, ...parameters: PluginParameters) =>\r\n *     Input extends string ? // Parser.\r\n *        Output extends Node | undefined ? undefined | void : never :\r\n *     Output extends CompileResults ? // Compiler.\r\n *        Input extends Node | undefined ? undefined | void : never :\r\n *     Transformer<\r\n *       Input extends Node ? Input : Node,\r\n *       Output extends Node ? Output : Node\r\n *     > | undefined | void\r\n * )} Plugin\r\n *   Single plugin.\r\n *\r\n *   Plugins configure the processors they are applied on in the following\r\n *   ways:\r\n *\r\n *   *   they change the processor, such as the parser, the compiler, or by\r\n *       configuring data\r\n *   *   they specify how to handle trees and files\r\n *\r\n *   In practice, they are functions that can receive options and configure the\r\n *   processor (`this`).\r\n *\r\n *   > ðŸ‘‰ **Note**: plugins are called when the processor is *frozen*, not when\r\n *   > they are applied.\r\n */\r\n\r\n/**\r\n * Tuple of a plugin and its configuration.\r\n *\r\n * The first item is a plugin, the rest are its parameters.\r\n *\r\n * @template {Array<unknown>} [TupleParameters=[]]\r\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\r\n * @template {Node | string | undefined} [Input=undefined]\r\n *   Value that is expected as input (optional).\r\n *\r\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\r\n *       should be the node it expects.\r\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be\r\n *       `string`.\r\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be the\r\n *       node it expects.\r\n * @template [Output=undefined] (optional).\r\n *   Value that is yielded as output.\r\n *\r\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\r\n *       should be the node that that yields.\r\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be the\r\n *       node that it yields.\r\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be\r\n *       result it yields.\r\n * @typedef {(\r\n *   [\r\n *     plugin: Plugin<TupleParameters, Input, Output>,\r\n *     ...parameters: TupleParameters\r\n *   ]\r\n * )} PluginTuple\r\n */\r\n\r\n/**\r\n * @typedef Preset\r\n *   Sharable configuration.\r\n *\r\n *   They can contain plugins and settings.\r\n * @property {PluggableList | undefined} [plugins]\r\n *   List of plugins and presets (optional).\r\n * @property {Settings | undefined} [settings]\r\n *   Shared settings for parsers and compilers (optional).\r\n */\r\n\r\n/**\r\n * @template {VFile} [File=VFile]\r\n *   The file that the callback receives (default: `VFile`).\r\n * @callback ProcessCallback\r\n *   Callback called when the process is done.\r\n *\r\n *   Called with either an error or a result.\r\n * @param {Error | undefined} [error]\r\n *   Fatal error (optional).\r\n * @param {File | undefined} [file]\r\n *   Processed file (optional).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\n\r\n/**\r\n * @template {Node} [Tree=Node]\r\n *   The tree that the callback receives (default: `Node`).\r\n * @callback RunCallback\r\n *   Callback called when transformers are done.\r\n *\r\n *   Called with either an error or results.\r\n * @param {Error | undefined} [error]\r\n *   Fatal error (optional).\r\n * @param {Tree | undefined} [tree]\r\n *   Transformed tree (optional).\r\n * @param {VFile | undefined} [file]\r\n *   File (optional).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\n\r\n/**\r\n * @template {Node} [Output=Node]\r\n *   Node type that the transformer yields (default: `Node`).\r\n * @callback TransformCallback\r\n *   Callback passed to transforms.\r\n *\r\n *   If the signature of a `transformer` accepts a third argument, the\r\n *   transformer may perform asynchronous operations, and must call it.\r\n * @param {Error | undefined} [error]\r\n *   Fatal error to stop the process (optional).\r\n * @param {Output | undefined} [tree]\r\n *   New, changed, tree (optional).\r\n * @param {VFile | undefined} [file]\r\n *   New, changed, file (optional).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\n\r\n/**\r\n * @template {Node} [Input=Node]\r\n *   Node type that the transformer expects (default: `Node`).\r\n * @template {Node} [Output=Input]\r\n *   Node type that the transformer yields (default: `Input`).\r\n * @callback Transformer\r\n *   Transformers handle syntax trees and files.\r\n *\r\n *   They are functions that are called each time a syntax tree and file are\r\n *   passed through the run phase.\r\n *   When an error occurs in them (either because itâ€™s thrown, returned,\r\n *   rejected, or passed to `next`), the process stops.\r\n *\r\n *   The run phase is handled by [`trough`][trough], see its documentation for\r\n *   the exact semantics of these functions.\r\n *\r\n *   > ðŸ‘‰ **Note**: you should likely ignore `next`: donâ€™t accept it.\r\n *   > it supports callback-style async work.\r\n *   > But promises are likely easier to reason about.\r\n *\r\n *   [trough]: https://github.com/wooorm/trough#function-fninput-next\r\n * @param {Input} tree\r\n *   Tree to handle.\r\n * @param {VFile} file\r\n *   File to handle.\r\n * @param {TransformCallback<Output>} next\r\n *   Callback.\r\n * @returns {(\r\n *   Promise<Output | undefined | void> |\r\n *   Promise<never> | // For some reason this is needed separately.\r\n *   Output |\r\n *   Error |\r\n *   undefined |\r\n *   void\r\n * )}\r\n *   If you accept `next`, nothing.\r\n *   Otherwise:\r\n *\r\n *   *   `Error` â€” fatal error to stop the process\r\n *   *   `Promise<undefined>` or `undefined` â€” the next transformer keeps using\r\n *       same tree\r\n *   *   `Promise<Node>` or `Node` â€” new, changed, tree\r\n */\r\n\r\n/**\r\n * @template {Node | undefined} ParseTree\r\n *   Output of `parse`.\r\n * @template {Node | undefined} HeadTree\r\n *   Input for `run`.\r\n * @template {Node | undefined} TailTree\r\n *   Output for `run`.\r\n * @template {Node | undefined} CompileTree\r\n *   Input of `stringify`.\r\n * @template {CompileResults | undefined} CompileResult\r\n *   Output of `stringify`.\r\n * @template {Node | string | undefined} Input\r\n *   Input of plugin.\r\n * @template Output\r\n *   Output of plugin (optional).\r\n * @typedef {(\r\n *   Input extends string\r\n *     ? Output extends Node | undefined\r\n *       ? // Parser.\r\n *         Processor<\r\n *           Output extends undefined ? ParseTree : Output,\r\n *           HeadTree,\r\n *           TailTree,\r\n *           CompileTree,\r\n *           CompileResult\r\n *         >\r\n *       : // Unknown.\r\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\r\n *     : Output extends CompileResults\r\n *     ? Input extends Node | undefined\r\n *       ? // Compiler.\r\n *         Processor<\r\n *           ParseTree,\r\n *           HeadTree,\r\n *           TailTree,\r\n *           Input extends undefined ? CompileTree : Input,\r\n *           Output extends undefined ? CompileResult : Output\r\n *         >\r\n *       : // Unknown.\r\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\r\n *     : Input extends Node | undefined\r\n *     ? Output extends Node | undefined\r\n *       ? // Transform.\r\n *         Processor<\r\n *           ParseTree,\r\n *           HeadTree extends undefined ? Input : HeadTree,\r\n *           Output extends undefined ? TailTree : Output,\r\n *           CompileTree,\r\n *           CompileResult\r\n *         >\r\n *       : // Unknown.\r\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\r\n *     : // Unknown.\r\n *       Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\r\n * )} UsePlugin\r\n *   Create a processor based on the input/output of a {@link Plugin plugin}.\r\n */\r\n\r\n/**\r\n * @template {CompileResults | undefined} Result\r\n *   Node type that the transformer yields.\r\n * @typedef {(\r\n *   Result extends Value | undefined ?\r\n *     VFile :\r\n *     VFile & {result: Result}\r\n *   )} VFileWithOutput\r\n *   Type to generate a {@link VFile `VFile`} corresponding to a compiler result.\r\n *\r\n *   If a result that is not acceptable on a `VFile` is used, that will\r\n *   be stored on the `result` field of {@link VFile `VFile`}.\r\n */\r\n\r\nimport {bail} from 'bail'\r\nimport extend from 'extend'\r\nimport {ok as assert} from 'devlop'\r\nimport isPlainObj from 'is-plain-obj'\r\nimport {trough} from 'trough'\r\nimport {VFile} from 'vfile'\r\nimport {CallableInstance} from './callable-instance.js'\r\n\r\n// To do: next major: drop `Compiler`, `Parser`: prefer lowercase.\r\n\r\n// To do: we could start yielding `never` in TS when a parser is missing and\r\n// `parse` is called.\r\n// Currently, we allow directly setting `processor.parser`, which is untyped.\r\n\r\nconst own = {}.hasOwnProperty\r\n\r\n/**\r\n * @template {Node | undefined} [ParseTree=undefined]\r\n *   Output of `parse` (optional).\r\n * @template {Node | undefined} [HeadTree=undefined]\r\n *   Input for `run` (optional).\r\n * @template {Node | undefined} [TailTree=undefined]\r\n *   Output for `run` (optional).\r\n * @template {Node | undefined} [CompileTree=undefined]\r\n *   Input of `stringify` (optional).\r\n * @template {CompileResults | undefined} [CompileResult=undefined]\r\n *   Output of `stringify` (optional).\r\n * @extends {CallableInstance<[], Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>>}\r\n */\r\nexport class Processor extends CallableInstance {\r\n  /**\r\n   * Create a processor.\r\n   */\r\n  constructor() {\r\n    // If `Processor()` is called (w/o new), `copy` is called instead.\r\n    super('copy')\r\n\r\n    /**\r\n     * Compiler to use (deprecated).\r\n     *\r\n     * @deprecated\r\n     *   Use `compiler` instead.\r\n     * @type {(\r\n     *   Compiler<\r\n     *     CompileTree extends undefined ? Node : CompileTree,\r\n     *     CompileResult extends undefined ? CompileResults : CompileResult\r\n     *   > |\r\n     *   undefined\r\n     * )}\r\n     */\r\n    this.Compiler = undefined\r\n\r\n    /**\r\n     * Parser to use (deprecated).\r\n     *\r\n     * @deprecated\r\n     *   Use `parser` instead.\r\n     * @type {(\r\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\r\n     *   undefined\r\n     * )}\r\n     */\r\n    this.Parser = undefined\r\n\r\n    // Note: the following fields are considered private.\r\n    // However, they are needed for tests, and TSC generates an untyped\r\n    // `private freezeIndex` field for, which trips `type-coverage` up.\r\n    // Instead, we use `@deprecated` to visualize that they shouldnâ€™t be used.\r\n    /**\r\n     * Internal list of configured plugins.\r\n     *\r\n     * @deprecated\r\n     *   This is a private internal property and should not be used.\r\n     * @type {Array<PluginTuple<Array<unknown>>>}\r\n     */\r\n    this.attachers = []\r\n\r\n    /**\r\n     * Compiler to use.\r\n     *\r\n     * @type {(\r\n     *   Compiler<\r\n     *     CompileTree extends undefined ? Node : CompileTree,\r\n     *     CompileResult extends undefined ? CompileResults : CompileResult\r\n     *   > |\r\n     *   undefined\r\n     * )}\r\n     */\r\n    this.compiler = undefined\r\n\r\n    /**\r\n     * Internal state to track where we are while freezing.\r\n     *\r\n     * @deprecated\r\n     *   This is a private internal property and should not be used.\r\n     * @type {number}\r\n     */\r\n    this.freezeIndex = -1\r\n\r\n    /**\r\n     * Internal state to track whether weâ€™re frozen.\r\n     *\r\n     * @deprecated\r\n     *   This is a private internal property and should not be used.\r\n     * @type {boolean | undefined}\r\n     */\r\n    this.frozen = undefined\r\n\r\n    /**\r\n     * Internal state.\r\n     *\r\n     * @deprecated\r\n     *   This is a private internal property and should not be used.\r\n     * @type {Data}\r\n     */\r\n    this.namespace = {}\r\n\r\n    /**\r\n     * Parser to use.\r\n     *\r\n     * @type {(\r\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\r\n     *   undefined\r\n     * )}\r\n     */\r\n    this.parser = undefined\r\n\r\n    /**\r\n     * Internal list of configured transformers.\r\n     *\r\n     * @deprecated\r\n     *   This is a private internal property and should not be used.\r\n     * @type {Pipeline}\r\n     */\r\n    this.transformers = trough()\r\n  }\r\n\r\n  /**\r\n   * Copy a processor.\r\n   *\r\n   * @deprecated\r\n   *   This is a private internal method and should not be used.\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *   New *unfrozen* processor ({@link Processor `Processor`}) that is\r\n   *   configured to work the same as its ancestor.\r\n   *   When the descendant processor is configured in the future it does not\r\n   *   affect the ancestral processor.\r\n   */\r\n  copy() {\r\n    // Cast as the type parameters will be the same after attaching.\r\n    const destination =\r\n      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */ (\r\n        new Processor()\r\n      )\r\n    let index = -1\r\n\r\n    while (++index < this.attachers.length) {\r\n      const attacher = this.attachers[index]\r\n      destination.use(...attacher)\r\n    }\r\n\r\n    destination.data(extend(true, {}, this.namespace))\r\n\r\n    return destination\r\n  }\r\n\r\n  /**\r\n   * Configure the processor with info available to all plugins.\r\n   * Information is stored in an object.\r\n   *\r\n   * Typically, options can be given to a specific plugin, but sometimes it\r\n   * makes sense to have information shared with several plugins.\r\n   * For example, a list of HTML elements that are self-closing, which is\r\n   * needed during all phases.\r\n   *\r\n   * > ðŸ‘‰ **Note**: setting information cannot occur on *frozen* processors.\r\n   * > Call the processor first to create a new unfrozen processor.\r\n   *\r\n   * > ðŸ‘‰ **Note**: to register custom data in TypeScript, augment the\r\n   * > {@link Data `Data`} interface.\r\n   *\r\n   * @example\r\n   *   This example show how to get and set info:\r\n   *\r\n   *   ```js\r\n   *   import {unified} from 'unified'\r\n   *\r\n   *   const processor = unified().data('alpha', 'bravo')\r\n   *\r\n   *   processor.data('alpha') // => 'bravo'\r\n   *\r\n   *   processor.data() // => {alpha: 'bravo'}\r\n   *\r\n   *   processor.data({charlie: 'delta'})\r\n   *\r\n   *   processor.data() // => {charlie: 'delta'}\r\n   *   ```\r\n   *\r\n   * @template {keyof Data} Key\r\n   *\r\n   * @overload\r\n   * @returns {Data}\r\n   *\r\n   * @overload\r\n   * @param {Data} dataset\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *\r\n   * @overload\r\n   * @param {Key} key\r\n   * @returns {Data[Key]}\r\n   *\r\n   * @overload\r\n   * @param {Key} key\r\n   * @param {Data[Key]} value\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *\r\n   * @param {Data | Key} [key]\r\n   *   Key to get or set, or entire dataset to set, or nothing to get the\r\n   *   entire dataset (optional).\r\n   * @param {Data[Key]} [value]\r\n   *   Value to set (optional).\r\n   * @returns {unknown}\r\n   *   The current processor when setting, the value at `key` when getting, or\r\n   *   the entire dataset when getting without key.\r\n   */\r\n  data(key, value) {\r\n    if (typeof key === 'string') {\r\n      // Set `key`.\r\n      if (arguments.length === 2) {\r\n        assertUnfrozen('data', this.frozen)\r\n        this.namespace[key] = value\r\n        return this\r\n      }\r\n\r\n      // Get `key`.\r\n      return (own.call(this.namespace, key) && this.namespace[key]) || undefined\r\n    }\r\n\r\n    // Set space.\r\n    if (key) {\r\n      assertUnfrozen('data', this.frozen)\r\n      this.namespace = key\r\n      return this\r\n    }\r\n\r\n    // Get space.\r\n    return this.namespace\r\n  }\r\n\r\n  /**\r\n   * Freeze a processor.\r\n   *\r\n   * Frozen processors are meant to be extended and not to be configured\r\n   * directly.\r\n   *\r\n   * When a processor is frozen it cannot be unfrozen.\r\n   * New processors working the same way can be created by calling the\r\n   * processor.\r\n   *\r\n   * Itâ€™s possible to freeze processors explicitly by calling `.freeze()`.\r\n   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,\r\n   * `.stringify()`, `.process()`, or `.processSync()` are called.\r\n   *\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *   The current processor.\r\n   */\r\n  freeze() {\r\n    if (this.frozen) {\r\n      return this\r\n    }\r\n\r\n    // Cast so that we can type plugins easier.\r\n    // Plugins are supposed to be usable on different processors, not just on\r\n    // this exact processor.\r\n    const self = /** @type {Processor} */ (/** @type {unknown} */ (this))\r\n\r\n    while (++this.freezeIndex < this.attachers.length) {\r\n      const [attacher, ...options] = this.attachers[this.freezeIndex]\r\n\r\n      if (options[0] === false) {\r\n        continue\r\n      }\r\n\r\n      if (options[0] === true) {\r\n        options[0] = undefined\r\n      }\r\n\r\n      const transformer = attacher.call(self, ...options)\r\n\r\n      if (typeof transformer === 'function') {\r\n        this.transformers.use(transformer)\r\n      }\r\n    }\r\n\r\n    this.frozen = true\r\n    this.freezeIndex = Number.POSITIVE_INFINITY\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Parse text to a syntax tree.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `parse` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `parse` performs the parse phase, not the run phase or other\r\n   * > phases.\r\n   *\r\n   * @param {Compatible | undefined} [file]\r\n   *   file to parse (optional); typically `string` or `VFile`; any value\r\n   *   accepted as `x` in `new VFile(x)`.\r\n   * @returns {ParseTree extends undefined ? Node : ParseTree}\r\n   *   Syntax tree representing `file`.\r\n   */\r\n  parse(file) {\r\n    this.freeze()\r\n    const realFile = vfile(file)\r\n    const parser = this.parser || this.Parser\r\n    assertParser('parse', parser)\r\n    return parser(String(realFile), realFile)\r\n  }\r\n\r\n  /**\r\n   * Process the given file as configured on the processor.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `process` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `process` performs the parse, run, and stringify phases.\r\n   *\r\n   * @overload\r\n   * @param {Compatible | undefined} file\r\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done\r\n   * @returns {undefined}\r\n   *\r\n   * @overload\r\n   * @param {Compatible | undefined} [file]\r\n   * @returns {Promise<VFileWithOutput<CompileResult>>}\r\n   *\r\n   * @param {Compatible | undefined} [file]\r\n   *   File (optional); typically `string` or `VFile`]; any value accepted as\r\n   *   `x` in `new VFile(x)`.\r\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]\r\n   *   Callback (optional).\r\n   * @returns {Promise<VFile> | undefined}\r\n   *   Nothing if `done` is given.\r\n   *   Otherwise a promise, rejected with a fatal error or resolved with the\r\n   *   processed file.\r\n   *\r\n   *   The parsed, transformed, and compiled value is available at\r\n   *   `file.value` (see note).\r\n   *\r\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most\r\n   *   > compilers return `string` (or `Uint8Array`).\r\n   *   > Some compilers, such as the one configured with\r\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\r\n   *   > React tree).\r\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\r\n   *   > result values.\r\n   *   >\r\n   *   > To register custom results in TypeScript, add them to\r\n   *   > {@link CompileResultMap `CompileResultMap`}.\r\n   *\r\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\r\n   */\r\n  process(file, done) {\r\n    const self = this\r\n\r\n    this.freeze()\r\n    assertParser('process', this.parser || this.Parser)\r\n    assertCompiler('process', this.compiler || this.Compiler)\r\n\r\n    return done ? executor(undefined, done) : new Promise(executor)\r\n\r\n    // Note: `void`s needed for TS.\r\n    /**\r\n     * @param {((file: VFileWithOutput<CompileResult>) => undefined | void) | undefined} resolve\r\n     * @param {(error: Error | undefined) => undefined | void} reject\r\n     * @returns {undefined}\r\n     */\r\n    function executor(resolve, reject) {\r\n      const realFile = vfile(file)\r\n      // Assume `ParseTree` (the result of the parser) matches `HeadTree` (the\r\n      // input of the first transform).\r\n      const parseTree =\r\n        /** @type {HeadTree extends undefined ? Node : HeadTree} */ (\r\n          /** @type {unknown} */ (self.parse(realFile))\r\n        )\r\n\r\n      self.run(parseTree, realFile, function (error, tree, file) {\r\n        if (error || !tree || !file) {\r\n          return realDone(error)\r\n        }\r\n\r\n        // Assume `TailTree` (the output of the last transform) matches\r\n        // `CompileTree` (the input of the compiler).\r\n        const compileTree =\r\n          /** @type {CompileTree extends undefined ? Node : CompileTree} */ (\r\n            /** @type {unknown} */ (tree)\r\n          )\r\n\r\n        const compileResult = self.stringify(compileTree, file)\r\n\r\n        if (looksLikeAValue(compileResult)) {\r\n          file.value = compileResult\r\n        } else {\r\n          file.result = compileResult\r\n        }\r\n\r\n        realDone(error, /** @type {VFileWithOutput<CompileResult>} */ (file))\r\n      })\r\n\r\n      /**\r\n       * @param {Error | undefined} error\r\n       * @param {VFileWithOutput<CompileResult> | undefined} [file]\r\n       * @returns {undefined}\r\n       */\r\n      function realDone(error, file) {\r\n        if (error || !file) {\r\n          reject(error)\r\n        } else if (resolve) {\r\n          resolve(file)\r\n        } else {\r\n          assert(done, '`done` is defined if `resolve` is not')\r\n          done(undefined, file)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process the given file as configured on the processor.\r\n   *\r\n   * An error is thrown if asynchronous transforms are configured.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `processSync` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `processSync` performs the parse, run, and stringify phases.\r\n   *\r\n   * @param {Compatible | undefined} [file]\r\n   *   File (optional); typically `string` or `VFile`; any value accepted as\r\n   *   `x` in `new VFile(x)`.\r\n   * @returns {VFileWithOutput<CompileResult>}\r\n   *   The processed file.\r\n   *\r\n   *   The parsed, transformed, and compiled value is available at\r\n   *   `file.value` (see note).\r\n   *\r\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most\r\n   *   > compilers return `string` (or `Uint8Array`).\r\n   *   > Some compilers, such as the one configured with\r\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\r\n   *   > React tree).\r\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\r\n   *   > result values.\r\n   *   >\r\n   *   > To register custom results in TypeScript, add them to\r\n   *   > {@link CompileResultMap `CompileResultMap`}.\r\n   *\r\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\r\n   */\r\n  processSync(file) {\r\n    /** @type {boolean} */\r\n    let complete = false\r\n    /** @type {VFileWithOutput<CompileResult> | undefined} */\r\n    let result\r\n\r\n    this.freeze()\r\n    assertParser('processSync', this.parser || this.Parser)\r\n    assertCompiler('processSync', this.compiler || this.Compiler)\r\n\r\n    this.process(file, realDone)\r\n    assertDone('processSync', 'process', complete)\r\n    assert(result, 'we either bailed on an error or have a tree')\r\n\r\n    return result\r\n\r\n    /**\r\n     * @type {ProcessCallback<VFileWithOutput<CompileResult>>}\r\n     */\r\n    function realDone(error, file) {\r\n      complete = true\r\n      bail(error)\r\n      result = file\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run *transformers* on a syntax tree.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `run` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `run` performs the run phase, not other phases.\r\n   *\r\n   * @overload\r\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\r\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\r\n   * @returns {undefined}\r\n   *\r\n   * @overload\r\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\r\n   * @param {Compatible | undefined} file\r\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\r\n   * @returns {undefined}\r\n   *\r\n   * @overload\r\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\r\n   * @param {Compatible | undefined} [file]\r\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}\r\n   *\r\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\r\n   *   Tree to transform and inspect.\r\n   * @param {(\r\n   *   RunCallback<TailTree extends undefined ? Node : TailTree> |\r\n   *   Compatible\r\n   * )} [file]\r\n   *   File associated with `node` (optional); any value accepted as `x` in\r\n   *   `new VFile(x)`.\r\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]\r\n   *   Callback (optional).\r\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}\r\n   *   Nothing if `done` is given.\r\n   *   Otherwise, a promise rejected with a fatal error or resolved with the\r\n   *   transformed tree.\r\n   */\r\n  run(tree, file, done) {\r\n    assertNode(tree)\r\n    this.freeze()\r\n\r\n    const transformers = this.transformers\r\n\r\n    if (!done && typeof file === 'function') {\r\n      done = file\r\n      file = undefined\r\n    }\r\n\r\n    return done ? executor(undefined, done) : new Promise(executor)\r\n\r\n    // Note: `void`s needed for TS.\r\n    /**\r\n     * @param {(\r\n     *   ((tree: TailTree extends undefined ? Node : TailTree) => undefined | void) |\r\n     *   undefined\r\n     * )} resolve\r\n     * @param {(error: Error) => undefined | void} reject\r\n     * @returns {undefined}\r\n     */\r\n    function executor(resolve, reject) {\r\n      assert(\r\n        typeof file !== 'function',\r\n        '`file` canâ€™t be a `done` anymore, we checked'\r\n      )\r\n      const realFile = vfile(file)\r\n      transformers.run(tree, realFile, realDone)\r\n\r\n      /**\r\n       * @param {Error | undefined} error\r\n       * @param {Node} outputTree\r\n       * @param {VFile} file\r\n       * @returns {undefined}\r\n       */\r\n      function realDone(error, outputTree, file) {\r\n        const resultingTree =\r\n          /** @type {TailTree extends undefined ? Node : TailTree} */ (\r\n            outputTree || tree\r\n          )\r\n\r\n        if (error) {\r\n          reject(error)\r\n        } else if (resolve) {\r\n          resolve(resultingTree)\r\n        } else {\r\n          assert(done, '`done` is defined if `resolve` is not')\r\n          done(undefined, resultingTree, file)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run *transformers* on a syntax tree.\r\n   *\r\n   * An error is thrown if asynchronous transforms are configured.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `runSync` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `runSync` performs the run phase, not other phases.\r\n   *\r\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\r\n   *   Tree to transform and inspect.\r\n   * @param {Compatible | undefined} [file]\r\n   *   File associated with `node` (optional); any value accepted as `x` in\r\n   *   `new VFile(x)`.\r\n   * @returns {TailTree extends undefined ? Node : TailTree}\r\n   *   Transformed tree.\r\n   */\r\n  runSync(tree, file) {\r\n    /** @type {boolean} */\r\n    let complete = false\r\n    /** @type {(TailTree extends undefined ? Node : TailTree) | undefined} */\r\n    let result\r\n\r\n    this.run(tree, file, realDone)\r\n\r\n    assertDone('runSync', 'run', complete)\r\n    assert(result, 'we either bailed on an error or have a tree')\r\n    return result\r\n\r\n    /**\r\n     * @type {RunCallback<TailTree extends undefined ? Node : TailTree>}\r\n     */\r\n    function realDone(error, tree) {\r\n      bail(error)\r\n      result = tree\r\n      complete = true\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compile a syntax tree.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `stringify` freezes the processor if not already *frozen*.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `stringify` performs the stringify phase, not the run phase\r\n   * > or other phases.\r\n   *\r\n   * @param {CompileTree extends undefined ? Node : CompileTree} tree\r\n   *   Tree to compile.\r\n   * @param {Compatible | undefined} [file]\r\n   *   File associated with `node` (optional); any value accepted as `x` in\r\n   *   `new VFile(x)`.\r\n   * @returns {CompileResult extends undefined ? Value : CompileResult}\r\n   *   Textual representation of the tree (see note).\r\n   *\r\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most compilers\r\n   *   > return `string` (or `Uint8Array`).\r\n   *   > Some compilers, such as the one configured with\r\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\r\n   *   > React tree).\r\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\r\n   *   > result values.\r\n   *   >\r\n   *   > To register custom results in TypeScript, add them to\r\n   *   > {@link CompileResultMap `CompileResultMap`}.\r\n   *\r\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\r\n   */\r\n  stringify(tree, file) {\r\n    this.freeze()\r\n    const realFile = vfile(file)\r\n    const compiler = this.compiler || this.Compiler\r\n    assertCompiler('stringify', compiler)\r\n    assertNode(tree)\r\n\r\n    return compiler(tree, realFile)\r\n  }\r\n\r\n  /**\r\n   * Configure the processor to use a plugin, a list of usable values, or a\r\n   * preset.\r\n   *\r\n   * If the processor is already using a plugin, the previous plugin\r\n   * configuration is changed based on the options that are passed in.\r\n   * In other words, the plugin is not added a second time.\r\n   *\r\n   * > ðŸ‘‰ **Note**: `use` cannot be called on *frozen* processors.\r\n   * > Call the processor first to create a new unfrozen processor.\r\n   *\r\n   * @example\r\n   *   There are many ways to pass plugins to `.use()`.\r\n   *   This example gives an overview:\r\n   *\r\n   *   ```js\r\n   *   import {unified} from 'unified'\r\n   *\r\n   *   unified()\r\n   *     // Plugin with options:\r\n   *     .use(pluginA, {x: true, y: true})\r\n   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\r\n   *     .use(pluginA, {y: false, z: true})\r\n   *     // Plugins:\r\n   *     .use([pluginB, pluginC])\r\n   *     // Two plugins, the second with options:\r\n   *     .use([pluginD, [pluginE, {}]])\r\n   *     // Preset with plugins and settings:\r\n   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\r\n   *     // Settings only:\r\n   *     .use({settings: {position: false}})\r\n   *   ```\r\n   *\r\n   * @template {Array<unknown>} [Parameters=[]]\r\n   * @template {Node | string | undefined} [Input=undefined]\r\n   * @template [Output=Input]\r\n   *\r\n   * @overload\r\n   * @param {Preset | null | undefined} [preset]\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *\r\n   * @overload\r\n   * @param {PluggableList} list\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *\r\n   * @overload\r\n   * @param {Plugin<Parameters, Input, Output>} plugin\r\n   * @param {...(Parameters | [boolean])} parameters\r\n   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}\r\n   *\r\n   * @param {PluggableList | Plugin | Preset | null | undefined} value\r\n   *   Usable value.\r\n   * @param {...unknown} parameters\r\n   *   Parameters, when a plugin is given as a usable value.\r\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\r\n   *   Current processor.\r\n   */\r\n  use(value, ...parameters) {\r\n    const attachers = this.attachers\r\n    const namespace = this.namespace\r\n\r\n    assertUnfrozen('use', this.frozen)\r\n\r\n    if (value === null || value === undefined) {\r\n      // Empty.\r\n    } else if (typeof value === 'function') {\r\n      addPlugin(value, parameters)\r\n    } else if (typeof value === 'object') {\r\n      if (Array.isArray(value)) {\r\n        addList(value)\r\n      } else {\r\n        addPreset(value)\r\n      }\r\n    } else {\r\n      throw new TypeError('Expected usable value, not `' + value + '`')\r\n    }\r\n\r\n    return this\r\n\r\n    /**\r\n     * @param {Pluggable} value\r\n     * @returns {undefined}\r\n     */\r\n    function add(value) {\r\n      if (typeof value === 'function') {\r\n        addPlugin(value, [])\r\n      } else if (typeof value === 'object') {\r\n        if (Array.isArray(value)) {\r\n          const [plugin, ...parameters] =\r\n            /** @type {PluginTuple<Array<unknown>>} */ (value)\r\n          addPlugin(plugin, parameters)\r\n        } else {\r\n          addPreset(value)\r\n        }\r\n      } else {\r\n        throw new TypeError('Expected usable value, not `' + value + '`')\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @param {Preset} result\r\n     * @returns {undefined}\r\n     */\r\n    function addPreset(result) {\r\n      if (!('plugins' in result) && !('settings' in result)) {\r\n        throw new Error(\r\n          'Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither'\r\n        )\r\n      }\r\n\r\n      addList(result.plugins)\r\n\r\n      if (result.settings) {\r\n        namespace.settings = extend(true, namespace.settings, result.settings)\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @param {PluggableList | null | undefined} plugins\r\n     * @returns {undefined}\r\n     */\r\n    function addList(plugins) {\r\n      let index = -1\r\n\r\n      if (plugins === null || plugins === undefined) {\r\n        // Empty.\r\n      } else if (Array.isArray(plugins)) {\r\n        while (++index < plugins.length) {\r\n          const thing = plugins[index]\r\n          add(thing)\r\n        }\r\n      } else {\r\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @param {Plugin} plugin\r\n     * @param {Array<unknown>} parameters\r\n     * @returns {undefined}\r\n     */\r\n    function addPlugin(plugin, parameters) {\r\n      let index = -1\r\n      let entryIndex = -1\r\n\r\n      while (++index < attachers.length) {\r\n        if (attachers[index][0] === plugin) {\r\n          entryIndex = index\r\n          break\r\n        }\r\n      }\r\n\r\n      if (entryIndex === -1) {\r\n        attachers.push([plugin, ...parameters])\r\n      }\r\n      // Only set if there was at least a `primary` value, otherwise weâ€™d change\r\n      // `arguments.length`.\r\n      else if (parameters.length > 0) {\r\n        let [primary, ...rest] = parameters\r\n        const currentPrimary = attachers[entryIndex][1]\r\n        if (isPlainObj(currentPrimary) && isPlainObj(primary)) {\r\n          primary = extend(true, currentPrimary, primary)\r\n        }\r\n\r\n        attachers[entryIndex] = [plugin, primary, ...rest]\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Note: this returns a *callable* instance.\r\n// Thatâ€™s why itâ€™s documented as a function.\r\n/**\r\n * Create a new processor.\r\n *\r\n * @example\r\n *   This example shows how a new processor can be created (from `remark`) and linked\r\n *   to **stdin**(4) and **stdout**(4).\r\n *\r\n *   ```js\r\n *   import process from 'node:process'\r\n *   import concatStream from 'concat-stream'\r\n *   import {remark} from 'remark'\r\n *\r\n *   process.stdin.pipe(\r\n *     concatStream(function (buf) {\r\n *       process.stdout.write(String(remark().processSync(buf)))\r\n *     })\r\n *   )\r\n *   ```\r\n *\r\n * @returns\r\n *   New *unfrozen* processor (`processor`).\r\n *\r\n *   This processor is configured to work the same as its ancestor.\r\n *   When the descendant processor is configured in the future it does not\r\n *   affect the ancestral processor.\r\n */\r\nexport const unified = new Processor().freeze()\r\n\r\n/**\r\n * Assert a parser is available.\r\n *\r\n * @param {string} name\r\n * @param {unknown} value\r\n * @returns {asserts value is Parser}\r\n */\r\nfunction assertParser(name, value) {\r\n  if (typeof value !== 'function') {\r\n    throw new TypeError('Cannot `' + name + '` without `parser`')\r\n  }\r\n}\r\n\r\n/**\r\n * Assert a compiler is available.\r\n *\r\n * @param {string} name\r\n * @param {unknown} value\r\n * @returns {asserts value is Compiler}\r\n */\r\nfunction assertCompiler(name, value) {\r\n  if (typeof value !== 'function') {\r\n    throw new TypeError('Cannot `' + name + '` without `compiler`')\r\n  }\r\n}\r\n\r\n/**\r\n * Assert the processor is not frozen.\r\n *\r\n * @param {string} name\r\n * @param {unknown} frozen\r\n * @returns {asserts frozen is false}\r\n */\r\nfunction assertUnfrozen(name, frozen) {\r\n  if (frozen) {\r\n    throw new Error(\r\n      'Cannot call `' +\r\n        name +\r\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Assert `node` is a unist node.\r\n *\r\n * @param {unknown} node\r\n * @returns {asserts node is Node}\r\n */\r\nfunction assertNode(node) {\r\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\r\n  // type-coverage:ignore-next-line\r\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\r\n    throw new TypeError('Expected node, got `' + node + '`')\r\n    // Fine.\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that `complete` is `true`.\r\n *\r\n * @param {string} name\r\n * @param {string} asyncName\r\n * @param {unknown} complete\r\n * @returns {asserts complete is true}\r\n */\r\nfunction assertDone(name, asyncName, complete) {\r\n  if (!complete) {\r\n    throw new Error(\r\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Compatible | undefined} [value]\r\n * @returns {VFile}\r\n */\r\nfunction vfile(value) {\r\n  return looksLikeAVFile(value) ? value : new VFile(value)\r\n}\r\n\r\n/**\r\n * @param {Compatible | undefined} [value]\r\n * @returns {value is VFile}\r\n */\r\nfunction looksLikeAVFile(value) {\r\n  return Boolean(\r\n    value &&\r\n      typeof value === 'object' &&\r\n      'message' in value &&\r\n      'messages' in value\r\n  )\r\n}\r\n\r\n/**\r\n * @param {unknown} [value]\r\n * @returns {value is Value}\r\n */\r\nfunction looksLikeAValue(value) {\r\n  return typeof value === 'string' || isUint8Array(value)\r\n}\r\n\r\n/**\r\n * Assert `value` is an `Uint8Array`.\r\n *\r\n * @param {unknown} value\r\n *   thing.\r\n * @returns {value is Uint8Array}\r\n *   Whether `value` is an `Uint8Array`.\r\n */\r\nfunction isUint8Array(value) {\r\n  return Boolean(\r\n    value &&\r\n      typeof value === 'object' &&\r\n      'byteLength' in value &&\r\n      'byteOffset' in value\r\n  )\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,IAAI,QAAO,MAAM;AACzB,OAAOC,MAAM,MAAM,QAAQ;AAC3B,SAAQC,EAAE,IAAIC,MAAM,QAAO,QAAQ;AACnC,OAAOC,UAAU,MAAM,cAAc;AACrC,SAAQC,MAAM,QAAO,QAAQ;AAC7B,SAAQC,KAAK,QAAO,OAAO;AAC3B,SAAQC,gBAAgB,QAAO,wBAAwB;;AAEvD;;AAEA;AACA;AACA;;AAEA,MAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,SAAS,SAASH,gBAAgB,CAAC;EAC9C;AACF;AACA;EACEI,WAAWA,CAAA,EAAG;IACZ;IACA,KAAK,CAAC,MAAM,CAAC;;IAEb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,QAAQ,GAAGC,SAAS;;IAEzB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,MAAM,GAAGD,SAAS;;IAEvB;IACA;IACA;IACA;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACE,SAAS,GAAG,EAAE;;IAEnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,QAAQ,GAAGH,SAAS;;IAEzB;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACI,WAAW,GAAG,CAAC,CAAC;;IAErB;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,MAAM,GAAGL,SAAS;;IAEvB;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACM,SAAS,GAAG,CAAC,CAAC;;IAEnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,MAAM,GAAGP,SAAS;;IAEvB;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACQ,YAAY,GAAGhB,MAAM,CAAC,CAAC;EAC9B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEiB,IAAIA,CAAA,EAAG;IACL;IACA,MAAMC,WAAW,GACf;IACE,IAAIb,SAAS,CAAC,CACf;IACH,IAAIc,KAAK,GAAG,CAAC,CAAC;IAEd,OAAO,EAAEA,KAAK,GAAG,IAAI,CAACT,SAAS,CAACU,MAAM,EAAE;MACtC,MAAMC,QAAQ,GAAG,IAAI,CAACX,SAAS,CAACS,KAAK,CAAC;MACtCD,WAAW,CAACI,GAAG,CAAC,GAAGD,QAAQ,CAAC;IAC9B;IAEAH,WAAW,CAACK,IAAI,CAAC3B,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,IAAI,CAACkB,SAAS,CAAC,CAAC;IAElD,OAAOI,WAAW;EACpB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEK,IAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}