{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').Event} Event\r\n * @typedef {import('micromark-util-types').Exiter} Exiter\r\n * @typedef {import('micromark-util-types').Extension} Extension\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n */\n\nimport { ok as assert } from 'devlop';\nimport { blankLine } from 'micromark-core-commonmark';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { codes, constants, types } from 'micromark-util-symbol';\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\r\n * Create an extension for `micromark` to enable GFM footnote syntax.\r\n *\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions` to\r\n *   enable GFM footnote syntax.\r\n */\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [codes.leftSquareBracket]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [codes.leftSquareBracket]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [codes.rightSquareBracket]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  };\n}\n\n// To do: remove after micromark update.\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {Token} */\n  let labelStart;\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1];\n    if (token.type === types.labelImage) {\n      labelStart = token;\n      break;\n    }\n\n    // Exit if we’ve walked far enough.\n    if (token.type === 'gfmFootnoteCall' || token.type === types.labelLink || token.type === types.label || token.type === types.image || token.type === types.link) {\n      break;\n    }\n  }\n  return start;\n\n  /**\r\n   * @type {State}\r\n   */\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`');\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code);\n    }\n    const id = normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    }));\n    if (id.codePointAt(0) !== codes.caret || !defined.includes(id.slice(1))) {\n      return nok(code);\n    }\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return ok(code);\n  }\n}\n\n// To do: remove after micromark update.\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length;\n  /** @type {Token | undefined} */\n  let labelStart;\n\n  // Find an opening.\n  while (index--) {\n    if (events[index][1].type === types.labelImage && events[index][0] === 'enter') {\n      labelStart = events[index][1];\n      break;\n    }\n  }\n  assert(labelStart, 'expected `labelStart` to resolve');\n\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = types.data;\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker';\n\n  // The whole (without `!`):\n  /** @type {Token} */\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  // The `^` marker\n  /** @type {Token} */\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  };\n  // Increment the end 1 character.\n  marker.end.column++;\n  marker.end.offset++;\n  marker.end._bufferIndex++;\n  /** @type {Token} */\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  };\n  /** @type {Token} */\n  const chunk = {\n    type: types.chunkString,\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  };\n\n  /** @type {Array<Event>} */\n  const replacement = [\n  // Take the `labelImageMarker` (now `data`, the `!`)\n  events[index + 1], events[index + 2], ['enter', call, context],\n  // The `[`\n  events[index + 3], events[index + 4],\n  // The `^`.\n  ['enter', marker, context], ['exit', marker, context],\n  // Everything in between.\n  ['enter', string, context], ['enter', chunk, context], ['exit', chunk, context], ['exit', string, context],\n  // The ending (`]`, properly parsed and labelled).\n  events[events.length - 2], events[events.length - 1], ['exit', call, context]];\n  events.splice(index, events.length - index + 1, ...replacement);\n  return events;\n}\n\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  let size = 0;\n  /** @type {boolean} */\n  let data;\n\n  // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We can’t do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n  return start;\n\n  /**\r\n   * Start of footnote label.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b] c\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`');\n    effects.enter('gfmFootnoteCall');\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return callStart;\n  }\n\n  /**\r\n   * After `[`, at `^`.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b] c\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function callStart(code) {\n    if (code !== codes.caret) return nok(code);\n    effects.enter('gfmFootnoteCallMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallMarker');\n    effects.enter('gfmFootnoteCallString');\n    effects.enter('chunkString').contentType = 'string';\n    return callData;\n  }\n\n  /**\r\n   * In label.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b] c\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function callData(code) {\n    if (\n    // Too long.\n    size > constants.linkReferenceSizeMax ||\n    // Closing brace with nothing.\n    code === codes.rightSquareBracket && !data ||\n    // Space or tab is not supported by GFM for some reason.\n    // `\\n` and `[` not being supported makes sense.\n    code === codes.eof || code === codes.leftSquareBracket || markdownLineEndingOrSpace(code)) {\n      return nok(code);\n    }\n    if (code === codes.rightSquareBracket) {\n      effects.exit('chunkString');\n      const token = effects.exit('gfmFootnoteCallString');\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code);\n      }\n      effects.enter('gfmFootnoteCallLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteCallLabelMarker');\n      effects.exit('gfmFootnoteCall');\n      return ok;\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n    size++;\n    effects.consume(code);\n    return code === codes.backslash ? callEscape : callData;\n  }\n\n  /**\r\n   * On character after escape.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b\\c] d\r\n   *           ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function callEscape(code) {\n    if (code === codes.leftSquareBracket || code === codes.backslash || code === codes.rightSquareBracket) {\n      effects.consume(code);\n      size++;\n      return callData;\n    }\n    return callData(code);\n  }\n}\n\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {string} */\n  let identifier;\n  let size = 0;\n  /** @type {boolean | undefined} */\n  let data;\n  return start;\n\n  /**\r\n   * Start of GFM footnote definition.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`');\n    effects.enter('gfmFootnoteDefinition')._container = true;\n    effects.enter('gfmFootnoteDefinitionLabel');\n    effects.enter('gfmFootnoteDefinitionLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteDefinitionLabelMarker');\n    return labelAtMarker;\n  }\n\n  /**\r\n   * In label, at caret.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function labelAtMarker(code) {\n    if (code === codes.caret) {\n      effects.enter('gfmFootnoteDefinitionMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionMarker');\n      effects.enter('gfmFootnoteDefinitionLabelString');\n      effects.enter('chunkString').contentType = 'string';\n      return labelInside;\n    }\n    return nok(code);\n  }\n\n  /**\r\n   * In label.\r\n   *\r\n   * > 👉 **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\r\n   * > definition labels.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function labelInside(code) {\n    if (\n    // Too long.\n    size > constants.linkReferenceSizeMax ||\n    // Closing brace with nothing.\n    code === codes.rightSquareBracket && !data ||\n    // Space or tab is not supported by GFM for some reason.\n    // `\\n` and `[` not being supported makes sense.\n    code === codes.eof || code === codes.leftSquareBracket || markdownLineEndingOrSpace(code)) {\n      return nok(code);\n    }\n    if (code === codes.rightSquareBracket) {\n      effects.exit('chunkString');\n      const token = effects.exit('gfmFootnoteDefinitionLabelString');\n      identifier = normalizeIdentifier(self.sliceSerialize(token));\n      effects.enter('gfmFootnoteDefinitionLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionLabelMarker');\n      effects.exit('gfmFootnoteDefinitionLabel');\n      return labelAfter;\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n    size++;\n    effects.consume(code);\n    return code === codes.backslash ? labelEscape : labelInside;\n  }\n\n  /**\r\n   * After `\\`, at a special character.\r\n   *\r\n   * > 👉 **Note**: `cmark-gfm` currently does not support escaped brackets:\r\n   * > <https://github.com/github/cmark-gfm/issues/240>\r\n   *\r\n   * ```markdown\r\n   * > | [^a\\*b]: c\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function labelEscape(code) {\n    if (code === codes.leftSquareBracket || code === codes.backslash || code === codes.rightSquareBracket) {\n      effects.consume(code);\n      size++;\n      return labelInside;\n    }\n    return labelInside(code);\n  }\n\n  /**\r\n   * After definition label.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function labelAfter(code) {\n    if (code === codes.colon) {\n      effects.enter('definitionMarker');\n      effects.consume(code);\n      effects.exit('definitionMarker');\n      if (!defined.includes(identifier)) {\n        defined.push(identifier);\n      }\n\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return factorySpace(effects, whitespaceAfter, 'gfmFootnoteDefinitionWhitespace');\n    }\n    return nok(code);\n  }\n\n  /**\r\n   * After definition prefix.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *           ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code);\n  }\n}\n\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok));\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition');\n}\n\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, afterPrefix, 'gfmFootnoteDefinitionIndent', constants.tabSize + 1);\n\n  /**\r\n   * @type {State}\r\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'gfmFootnoteDefinitionIndent' && tail[2].sliceSerialize(tail[1], true).length === constants.tabSize ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","blankLine","factorySpace","markdownLineEndingOrSpace","normalizeIdentifier","codes","constants","types","indent","tokenize","tokenizeIndent","partial","gfmFootnote","document","leftSquareBracket","tokenizeDefinitionStart","continuation","tokenizeDefinitionContinuation","exit","gfmFootnoteDefinitionEnd","text","tokenizeGfmFootnoteCall","rightSquareBracket","add","tokenizePotentialGfmFootnoteCall","resolveTo","resolveToPotentialGfmFootnoteCall","effects","nok","self","index","events","length","defined","parser","gfmFootnotes","labelStart","token","type","labelImage","labelLink","label","image","link","start","code","_balanced","id","sliceSerialize","end","now","codePointAt","caret","includes","slice","enter","consume","context","data","call","Object","assign","marker","column","offset","_bufferIndex","string","chunk","chunkString","contentType","replacement","splice","size","callStart","callData","linkReferenceSizeMax","eof","backslash","callEscape","identifier","_container","labelAtMarker","labelInside","labelAfter","labelEscape","colon","push","whitespaceAfter","check","attempt","afterPrefix","tabSize","tail"],"sources":["E:/Documents/2024-1 YBIGTA/Ybigta_BLOG/blog_git/Ybigta-Blog/frontend/node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').Event} Event\r\n * @typedef {import('micromark-util-types').Exiter} Exiter\r\n * @typedef {import('micromark-util-types').Extension} Extension\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {blankLine} from 'micromark-core-commonmark'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\r\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\r\nimport {codes, constants, types} from 'micromark-util-symbol'\r\n\r\nconst indent = {tokenize: tokenizeIndent, partial: true}\r\n\r\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\r\n// affects label start (image).\r\n// That will let us drop `tokenizePotentialGfmFootnote*`.\r\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\r\n// That can be removed when `micromark-extension-footnote` is archived.\r\n\r\n/**\r\n * Create an extension for `micromark` to enable GFM footnote syntax.\r\n *\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions` to\r\n *   enable GFM footnote syntax.\r\n */\r\nexport function gfmFootnote() {\r\n  /** @type {Extension} */\r\n  return {\r\n    document: {\r\n      [codes.leftSquareBracket]: {\r\n        tokenize: tokenizeDefinitionStart,\r\n        continuation: {tokenize: tokenizeDefinitionContinuation},\r\n        exit: gfmFootnoteDefinitionEnd\r\n      }\r\n    },\r\n    text: {\r\n      [codes.leftSquareBracket]: {tokenize: tokenizeGfmFootnoteCall},\r\n      [codes.rightSquareBracket]: {\r\n        add: 'after',\r\n        tokenize: tokenizePotentialGfmFootnoteCall,\r\n        resolveTo: resolveToPotentialGfmFootnoteCall\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// To do: remove after micromark update.\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\r\n  const self = this\r\n  let index = self.events.length\r\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\r\n  /** @type {Token} */\r\n  let labelStart\r\n\r\n  // Find an opening.\r\n  while (index--) {\r\n    const token = self.events[index][1]\r\n\r\n    if (token.type === types.labelImage) {\r\n      labelStart = token\r\n      break\r\n    }\r\n\r\n    // Exit if we’ve walked far enough.\r\n    if (\r\n      token.type === 'gfmFootnoteCall' ||\r\n      token.type === types.labelLink ||\r\n      token.type === types.label ||\r\n      token.type === types.image ||\r\n      token.type === types.link\r\n    ) {\r\n      break\r\n    }\r\n  }\r\n\r\n  return start\r\n\r\n  /**\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    assert(code === codes.rightSquareBracket, 'expected `]`')\r\n\r\n    if (!labelStart || !labelStart._balanced) {\r\n      return nok(code)\r\n    }\r\n\r\n    const id = normalizeIdentifier(\r\n      self.sliceSerialize({start: labelStart.end, end: self.now()})\r\n    )\r\n\r\n    if (id.codePointAt(0) !== codes.caret || !defined.includes(id.slice(1))) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.enter('gfmFootnoteCallLabelMarker')\r\n    effects.consume(code)\r\n    effects.exit('gfmFootnoteCallLabelMarker')\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n// To do: remove after micromark update.\r\n/** @type {Resolver} */\r\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\r\n  let index = events.length\r\n  /** @type {Token | undefined} */\r\n  let labelStart\r\n\r\n  // Find an opening.\r\n  while (index--) {\r\n    if (\r\n      events[index][1].type === types.labelImage &&\r\n      events[index][0] === 'enter'\r\n    ) {\r\n      labelStart = events[index][1]\r\n      break\r\n    }\r\n  }\r\n\r\n  assert(labelStart, 'expected `labelStart` to resolve')\r\n\r\n  // Change the `labelImageMarker` to a `data`.\r\n  events[index + 1][1].type = types.data\r\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'\r\n\r\n  // The whole (without `!`):\r\n  /** @type {Token} */\r\n  const call = {\r\n    type: 'gfmFootnoteCall',\r\n    start: Object.assign({}, events[index + 3][1].start),\r\n    end: Object.assign({}, events[events.length - 1][1].end)\r\n  }\r\n  // The `^` marker\r\n  /** @type {Token} */\r\n  const marker = {\r\n    type: 'gfmFootnoteCallMarker',\r\n    start: Object.assign({}, events[index + 3][1].end),\r\n    end: Object.assign({}, events[index + 3][1].end)\r\n  }\r\n  // Increment the end 1 character.\r\n  marker.end.column++\r\n  marker.end.offset++\r\n  marker.end._bufferIndex++\r\n  /** @type {Token} */\r\n  const string = {\r\n    type: 'gfmFootnoteCallString',\r\n    start: Object.assign({}, marker.end),\r\n    end: Object.assign({}, events[events.length - 1][1].start)\r\n  }\r\n  /** @type {Token} */\r\n  const chunk = {\r\n    type: types.chunkString,\r\n    contentType: 'string',\r\n    start: Object.assign({}, string.start),\r\n    end: Object.assign({}, string.end)\r\n  }\r\n\r\n  /** @type {Array<Event>} */\r\n  const replacement = [\r\n    // Take the `labelImageMarker` (now `data`, the `!`)\r\n    events[index + 1],\r\n    events[index + 2],\r\n    ['enter', call, context],\r\n    // The `[`\r\n    events[index + 3],\r\n    events[index + 4],\r\n    // The `^`.\r\n    ['enter', marker, context],\r\n    ['exit', marker, context],\r\n    // Everything in between.\r\n    ['enter', string, context],\r\n    ['enter', chunk, context],\r\n    ['exit', chunk, context],\r\n    ['exit', string, context],\r\n    // The ending (`]`, properly parsed and labelled).\r\n    events[events.length - 2],\r\n    events[events.length - 1],\r\n    ['exit', call, context]\r\n  ]\r\n\r\n  events.splice(index, events.length - index + 1, ...replacement)\r\n\r\n  return events\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\r\n  const self = this\r\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\r\n  let size = 0\r\n  /** @type {boolean} */\r\n  let data\r\n\r\n  // Note: the implementation of `markdown-rs` is different, because it houses\r\n  // core *and* extensions in one project.\r\n  // Therefore, it can include footnote logic inside `label-end`.\r\n  // We can’t do that, but luckily, we can parse footnotes in a simpler way than\r\n  // needed for labels.\r\n  return start\r\n\r\n  /**\r\n   * Start of footnote label.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b] c\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    assert(code === codes.leftSquareBracket, 'expected `[`')\r\n    effects.enter('gfmFootnoteCall')\r\n    effects.enter('gfmFootnoteCallLabelMarker')\r\n    effects.consume(code)\r\n    effects.exit('gfmFootnoteCallLabelMarker')\r\n    return callStart\r\n  }\r\n\r\n  /**\r\n   * After `[`, at `^`.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b] c\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function callStart(code) {\r\n    if (code !== codes.caret) return nok(code)\r\n\r\n    effects.enter('gfmFootnoteCallMarker')\r\n    effects.consume(code)\r\n    effects.exit('gfmFootnoteCallMarker')\r\n    effects.enter('gfmFootnoteCallString')\r\n    effects.enter('chunkString').contentType = 'string'\r\n    return callData\r\n  }\r\n\r\n  /**\r\n   * In label.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b] c\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function callData(code) {\r\n    if (\r\n      // Too long.\r\n      size > constants.linkReferenceSizeMax ||\r\n      // Closing brace with nothing.\r\n      (code === codes.rightSquareBracket && !data) ||\r\n      // Space or tab is not supported by GFM for some reason.\r\n      // `\\n` and `[` not being supported makes sense.\r\n      code === codes.eof ||\r\n      code === codes.leftSquareBracket ||\r\n      markdownLineEndingOrSpace(code)\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.exit('chunkString')\r\n      const token = effects.exit('gfmFootnoteCallString')\r\n\r\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\r\n        return nok(code)\r\n      }\r\n\r\n      effects.enter('gfmFootnoteCallLabelMarker')\r\n      effects.consume(code)\r\n      effects.exit('gfmFootnoteCallLabelMarker')\r\n      effects.exit('gfmFootnoteCall')\r\n      return ok\r\n    }\r\n\r\n    if (!markdownLineEndingOrSpace(code)) {\r\n      data = true\r\n    }\r\n\r\n    size++\r\n    effects.consume(code)\r\n    return code === codes.backslash ? callEscape : callData\r\n  }\r\n\r\n  /**\r\n   * On character after escape.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b\\c] d\r\n   *           ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function callEscape(code) {\r\n    if (\r\n      code === codes.leftSquareBracket ||\r\n      code === codes.backslash ||\r\n      code === codes.rightSquareBracket\r\n    ) {\r\n      effects.consume(code)\r\n      size++\r\n      return callData\r\n    }\r\n\r\n    return callData(code)\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeDefinitionStart(effects, ok, nok) {\r\n  const self = this\r\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\r\n  /** @type {string} */\r\n  let identifier\r\n  let size = 0\r\n  /** @type {boolean | undefined} */\r\n  let data\r\n\r\n  return start\r\n\r\n  /**\r\n   * Start of GFM footnote definition.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    assert(code === codes.leftSquareBracket, 'expected `[`')\r\n    effects.enter('gfmFootnoteDefinition')._container = true\r\n    effects.enter('gfmFootnoteDefinitionLabel')\r\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\r\n    effects.consume(code)\r\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\r\n    return labelAtMarker\r\n  }\r\n\r\n  /**\r\n   * In label, at caret.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function labelAtMarker(code) {\r\n    if (code === codes.caret) {\r\n      effects.enter('gfmFootnoteDefinitionMarker')\r\n      effects.consume(code)\r\n      effects.exit('gfmFootnoteDefinitionMarker')\r\n      effects.enter('gfmFootnoteDefinitionLabelString')\r\n      effects.enter('chunkString').contentType = 'string'\r\n      return labelInside\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * In label.\r\n   *\r\n   * > 👉 **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\r\n   * > definition labels.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function labelInside(code) {\r\n    if (\r\n      // Too long.\r\n      size > constants.linkReferenceSizeMax ||\r\n      // Closing brace with nothing.\r\n      (code === codes.rightSquareBracket && !data) ||\r\n      // Space or tab is not supported by GFM for some reason.\r\n      // `\\n` and `[` not being supported makes sense.\r\n      code === codes.eof ||\r\n      code === codes.leftSquareBracket ||\r\n      markdownLineEndingOrSpace(code)\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.exit('chunkString')\r\n      const token = effects.exit('gfmFootnoteDefinitionLabelString')\r\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\r\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\r\n      effects.consume(code)\r\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\r\n      effects.exit('gfmFootnoteDefinitionLabel')\r\n      return labelAfter\r\n    }\r\n\r\n    if (!markdownLineEndingOrSpace(code)) {\r\n      data = true\r\n    }\r\n\r\n    size++\r\n    effects.consume(code)\r\n    return code === codes.backslash ? labelEscape : labelInside\r\n  }\r\n\r\n  /**\r\n   * After `\\`, at a special character.\r\n   *\r\n   * > 👉 **Note**: `cmark-gfm` currently does not support escaped brackets:\r\n   * > <https://github.com/github/cmark-gfm/issues/240>\r\n   *\r\n   * ```markdown\r\n   * > | [^a\\*b]: c\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function labelEscape(code) {\r\n    if (\r\n      code === codes.leftSquareBracket ||\r\n      code === codes.backslash ||\r\n      code === codes.rightSquareBracket\r\n    ) {\r\n      effects.consume(code)\r\n      size++\r\n      return labelInside\r\n    }\r\n\r\n    return labelInside(code)\r\n  }\r\n\r\n  /**\r\n   * After definition label.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function labelAfter(code) {\r\n    if (code === codes.colon) {\r\n      effects.enter('definitionMarker')\r\n      effects.consume(code)\r\n      effects.exit('definitionMarker')\r\n\r\n      if (!defined.includes(identifier)) {\r\n        defined.push(identifier)\r\n      }\r\n\r\n      // Any whitespace after the marker is eaten, forming indented code\r\n      // is not possible.\r\n      // No space is also fine, just like a block quote marker.\r\n      return factorySpace(\r\n        effects,\r\n        whitespaceAfter,\r\n        'gfmFootnoteDefinitionWhitespace'\r\n      )\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * After definition prefix.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *           ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function whitespaceAfter(code) {\r\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\r\n  /// Start of footnote definition continuation.\r\n  ///\r\n  /// ```markdown\r\n  ///   | [^a]: b\r\n  /// > |     c\r\n  ///     ^\r\n  /// ```\r\n  //\r\n  // Either a blank line, which is okay, or an indented thing.\r\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\r\n}\r\n\r\n/** @type {Exiter} */\r\nfunction gfmFootnoteDefinitionEnd(effects) {\r\n  effects.exit('gfmFootnoteDefinition')\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeIndent(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return factorySpace(\r\n    effects,\r\n    afterPrefix,\r\n    'gfmFootnoteDefinitionIndent',\r\n    constants.tabSize + 1\r\n  )\r\n\r\n  /**\r\n   * @type {State}\r\n   */\r\n  function afterPrefix(code) {\r\n    const tail = self.events[self.events.length - 1]\r\n    return tail &&\r\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\r\n      tail[2].sliceSerialize(tail[1], true).length === constants.tabSize\r\n      ? ok(code)\r\n      : nok(code)\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,EAAE,IAAIC,MAAM,QAAO,QAAQ;AACnC,SAAQC,SAAS,QAAO,2BAA2B;AACnD,SAAQC,YAAY,QAAO,yBAAyB;AACpD,SAAQC,yBAAyB,QAAO,0BAA0B;AAClE,SAAQC,mBAAmB,QAAO,qCAAqC;AACvE,SAAQC,KAAK,EAAEC,SAAS,EAAEC,KAAK,QAAO,uBAAuB;AAE7D,MAAMC,MAAM,GAAG;EAACC,QAAQ,EAAEC,cAAc;EAAEC,OAAO,EAAE;AAAI,CAAC;;AAExD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAAA,EAAG;EAC5B;EACA,OAAO;IACLC,QAAQ,EAAE;MACR,CAACR,KAAK,CAACS,iBAAiB,GAAG;QACzBL,QAAQ,EAAEM,uBAAuB;QACjCC,YAAY,EAAE;UAACP,QAAQ,EAAEQ;QAA8B,CAAC;QACxDC,IAAI,EAAEC;MACR;IACF,CAAC;IACDC,IAAI,EAAE;MACJ,CAACf,KAAK,CAACS,iBAAiB,GAAG;QAACL,QAAQ,EAAEY;MAAuB,CAAC;MAC9D,CAAChB,KAAK,CAACiB,kBAAkB,GAAG;QAC1BC,GAAG,EAAE,OAAO;QACZd,QAAQ,EAAEe,gCAAgC;QAC1CC,SAAS,EAAEC;MACb;IACF;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASF,gCAAgCA,CAACG,OAAO,EAAE5B,EAAE,EAAE6B,GAAG,EAAE;EAC1D,MAAMC,IAAI,GAAG,IAAI;EACjB,IAAIC,KAAK,GAAGD,IAAI,CAACE,MAAM,CAACC,MAAM;EAC9B,MAAMC,OAAO,GAAGJ,IAAI,CAACK,MAAM,CAACC,YAAY,KAAKN,IAAI,CAACK,MAAM,CAACC,YAAY,GAAG,EAAE,CAAC;EAC3E;EACA,IAAIC,UAAU;;EAEd;EACA,OAAON,KAAK,EAAE,EAAE;IACd,MAAMO,KAAK,GAAGR,IAAI,CAACE,MAAM,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC;IAEnC,IAAIO,KAAK,CAACC,IAAI,KAAK/B,KAAK,CAACgC,UAAU,EAAE;MACnCH,UAAU,GAAGC,KAAK;MAClB;IACF;;IAEA;IACA,IACEA,KAAK,CAACC,IAAI,KAAK,iBAAiB,IAChCD,KAAK,CAACC,IAAI,KAAK/B,KAAK,CAACiC,SAAS,IAC9BH,KAAK,CAACC,IAAI,KAAK/B,KAAK,CAACkC,KAAK,IAC1BJ,KAAK,CAACC,IAAI,KAAK/B,KAAK,CAACmC,KAAK,IAC1BL,KAAK,CAACC,IAAI,KAAK/B,KAAK,CAACoC,IAAI,EACzB;MACA;IACF;EACF;EAEA,OAAOC,KAAK;;EAEZ;AACF;AACA;EACE,SAASA,KAAKA,CAACC,IAAI,EAAE;IACnB7C,MAAM,CAAC6C,IAAI,KAAKxC,KAAK,CAACiB,kBAAkB,EAAE,cAAc,CAAC;IAEzD,IAAI,CAACc,UAAU,IAAI,CAACA,UAAU,CAACU,SAAS,EAAE;MACxC,OAAOlB,GAAG,CAACiB,IAAI,CAAC;IAClB;IAEA,MAAME,EAAE,GAAG3C,mBAAmB,CAC5ByB,IAAI,CAACmB,cAAc,CAAC;MAACJ,KAAK,EAAER,UAAU,CAACa,GAAG;MAAEA,GAAG,EAAEpB,IAAI,CAACqB,GAAG,CAAC;IAAC,CAAC,CAC9D,CAAC;IAED,IAAIH,EAAE,CAACI,WAAW,CAAC,CAAC,CAAC,KAAK9C,KAAK,CAAC+C,KAAK,IAAI,CAACnB,OAAO,CAACoB,QAAQ,CAACN,EAAE,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;MACvE,OAAO1B,GAAG,CAACiB,IAAI,CAAC;IAClB;IAEAlB,OAAO,CAAC4B,KAAK,CAAC,4BAA4B,CAAC;IAC3C5B,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;IACrBlB,OAAO,CAACT,IAAI,CAAC,4BAA4B,CAAC;IAC1C,OAAOnB,EAAE,CAAC8C,IAAI,CAAC;EACjB;AACF;;AAEA;AACA;AACA,SAASnB,iCAAiCA,CAACK,MAAM,EAAE0B,OAAO,EAAE;EAC1D,IAAI3B,KAAK,GAAGC,MAAM,CAACC,MAAM;EACzB;EACA,IAAII,UAAU;;EAEd;EACA,OAAON,KAAK,EAAE,EAAE;IACd,IACEC,MAAM,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAACQ,IAAI,KAAK/B,KAAK,CAACgC,UAAU,IAC1CR,MAAM,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,EAC5B;MACAM,UAAU,GAAGL,MAAM,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC;MAC7B;IACF;EACF;EAEA9B,MAAM,CAACoC,UAAU,EAAE,kCAAkC,CAAC;;EAEtD;EACAL,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACQ,IAAI,GAAG/B,KAAK,CAACmD,IAAI;EACtC3B,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACQ,IAAI,GAAG,4BAA4B;;EAExD;EACA;EACA,MAAMqB,IAAI,GAAG;IACXrB,IAAI,EAAE,iBAAiB;IACvBM,KAAK,EAAEgB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE9B,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACc,KAAK,CAAC;IACpDK,GAAG,EAAEW,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE9B,MAAM,CAACA,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACiB,GAAG;EACzD,CAAC;EACD;EACA;EACA,MAAMa,MAAM,GAAG;IACbxB,IAAI,EAAE,uBAAuB;IAC7BM,KAAK,EAAEgB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE9B,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACmB,GAAG,CAAC;IAClDA,GAAG,EAAEW,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE9B,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACmB,GAAG;EACjD,CAAC;EACD;EACAa,MAAM,CAACb,GAAG,CAACc,MAAM,EAAE;EACnBD,MAAM,CAACb,GAAG,CAACe,MAAM,EAAE;EACnBF,MAAM,CAACb,GAAG,CAACgB,YAAY,EAAE;EACzB;EACA,MAAMC,MAAM,GAAG;IACb5B,IAAI,EAAE,uBAAuB;IAC7BM,KAAK,EAAEgB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEC,MAAM,CAACb,GAAG,CAAC;IACpCA,GAAG,EAAEW,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE9B,MAAM,CAACA,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACY,KAAK;EAC3D,CAAC;EACD;EACA,MAAMuB,KAAK,GAAG;IACZ7B,IAAI,EAAE/B,KAAK,CAAC6D,WAAW;IACvBC,WAAW,EAAE,QAAQ;IACrBzB,KAAK,EAAEgB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEK,MAAM,CAACtB,KAAK,CAAC;IACtCK,GAAG,EAAEW,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEK,MAAM,CAACjB,GAAG;EACnC,CAAC;;EAED;EACA,MAAMqB,WAAW,GAAG;EAClB;EACAvC,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,EACjBC,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,EACjB,CAAC,OAAO,EAAE6B,IAAI,EAAEF,OAAO,CAAC;EACxB;EACA1B,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,EACjBC,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC;EACjB;EACA,CAAC,OAAO,EAAEgC,MAAM,EAAEL,OAAO,CAAC,EAC1B,CAAC,MAAM,EAAEK,MAAM,EAAEL,OAAO,CAAC;EACzB;EACA,CAAC,OAAO,EAAES,MAAM,EAAET,OAAO,CAAC,EAC1B,CAAC,OAAO,EAAEU,KAAK,EAAEV,OAAO,CAAC,EACzB,CAAC,MAAM,EAAEU,KAAK,EAAEV,OAAO,CAAC,EACxB,CAAC,MAAM,EAAES,MAAM,EAAET,OAAO,CAAC;EACzB;EACA1B,MAAM,CAACA,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,EACzBD,MAAM,CAACA,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,EACzB,CAAC,MAAM,EAAE2B,IAAI,EAAEF,OAAO,CAAC,CACxB;EAED1B,MAAM,CAACwC,MAAM,CAACzC,KAAK,EAAEC,MAAM,CAACC,MAAM,GAAGF,KAAK,GAAG,CAAC,EAAE,GAAGwC,WAAW,CAAC;EAE/D,OAAOvC,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA,SAASV,uBAAuBA,CAACM,OAAO,EAAE5B,EAAE,EAAE6B,GAAG,EAAE;EACjD,MAAMC,IAAI,GAAG,IAAI;EACjB,MAAMI,OAAO,GAAGJ,IAAI,CAACK,MAAM,CAACC,YAAY,KAAKN,IAAI,CAACK,MAAM,CAACC,YAAY,GAAG,EAAE,CAAC;EAC3E,IAAIqC,IAAI,GAAG,CAAC;EACZ;EACA,IAAId,IAAI;;EAER;EACA;EACA;EACA;EACA;EACA,OAAOd,KAAK;;EAEZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,KAAKA,CAACC,IAAI,EAAE;IACnB7C,MAAM,CAAC6C,IAAI,KAAKxC,KAAK,CAACS,iBAAiB,EAAE,cAAc,CAAC;IACxDa,OAAO,CAAC4B,KAAK,CAAC,iBAAiB,CAAC;IAChC5B,OAAO,CAAC4B,KAAK,CAAC,4BAA4B,CAAC;IAC3C5B,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;IACrBlB,OAAO,CAACT,IAAI,CAAC,4BAA4B,CAAC;IAC1C,OAAOuD,SAAS;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,SAASA,CAAC5B,IAAI,EAAE;IACvB,IAAIA,IAAI,KAAKxC,KAAK,CAAC+C,KAAK,EAAE,OAAOxB,GAAG,CAACiB,IAAI,CAAC;IAE1ClB,OAAO,CAAC4B,KAAK,CAAC,uBAAuB,CAAC;IACtC5B,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;IACrBlB,OAAO,CAACT,IAAI,CAAC,uBAAuB,CAAC;IACrCS,OAAO,CAAC4B,KAAK,CAAC,uBAAuB,CAAC;IACtC5B,OAAO,CAAC4B,KAAK,CAAC,aAAa,CAAC,CAACc,WAAW,GAAG,QAAQ;IACnD,OAAOK,QAAQ;EACjB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,QAAQA,CAAC7B,IAAI,EAAE;IACtB;IACE;IACA2B,IAAI,GAAGlE,SAAS,CAACqE,oBAAoB;IACrC;IACC9B,IAAI,KAAKxC,KAAK,CAACiB,kBAAkB,IAAI,CAACoC,IAAK;IAC5C;IACA;IACAb,IAAI,KAAKxC,KAAK,CAACuE,GAAG,IAClB/B,IAAI,KAAKxC,KAAK,CAACS,iBAAiB,IAChCX,yBAAyB,CAAC0C,IAAI,CAAC,EAC/B;MACA,OAAOjB,GAAG,CAACiB,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAKxC,KAAK,CAACiB,kBAAkB,EAAE;MACrCK,OAAO,CAACT,IAAI,CAAC,aAAa,CAAC;MAC3B,MAAMmB,KAAK,GAAGV,OAAO,CAACT,IAAI,CAAC,uBAAuB,CAAC;MAEnD,IAAI,CAACe,OAAO,CAACoB,QAAQ,CAACjD,mBAAmB,CAACyB,IAAI,CAACmB,cAAc,CAACX,KAAK,CAAC,CAAC,CAAC,EAAE;QACtE,OAAOT,GAAG,CAACiB,IAAI,CAAC;MAClB;MAEAlB,OAAO,CAAC4B,KAAK,CAAC,4BAA4B,CAAC;MAC3C5B,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;MACrBlB,OAAO,CAACT,IAAI,CAAC,4BAA4B,CAAC;MAC1CS,OAAO,CAACT,IAAI,CAAC,iBAAiB,CAAC;MAC/B,OAAOnB,EAAE;IACX;IAEA,IAAI,CAACI,yBAAyB,CAAC0C,IAAI,CAAC,EAAE;MACpCa,IAAI,GAAG,IAAI;IACb;IAEAc,IAAI,EAAE;IACN7C,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;IACrB,OAAOA,IAAI,KAAKxC,KAAK,CAACwE,SAAS,GAAGC,UAAU,GAAGJ,QAAQ;EACzD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASI,UAAUA,CAACjC,IAAI,EAAE;IACxB,IACEA,IAAI,KAAKxC,KAAK,CAACS,iBAAiB,IAChC+B,IAAI,KAAKxC,KAAK,CAACwE,SAAS,IACxBhC,IAAI,KAAKxC,KAAK,CAACiB,kBAAkB,EACjC;MACAK,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;MACrB2B,IAAI,EAAE;MACN,OAAOE,QAAQ;IACjB;IAEA,OAAOA,QAAQ,CAAC7B,IAAI,CAAC;EACvB;AACF;;AAEA;AACA;AACA;AACA;AACA,SAAS9B,uBAAuBA,CAACY,OAAO,EAAE5B,EAAE,EAAE6B,GAAG,EAAE;EACjD,MAAMC,IAAI,GAAG,IAAI;EACjB,MAAMI,OAAO,GAAGJ,IAAI,CAACK,MAAM,CAACC,YAAY,KAAKN,IAAI,CAACK,MAAM,CAACC,YAAY,GAAG,EAAE,CAAC;EAC3E;EACA,IAAI4C,UAAU;EACd,IAAIP,IAAI,GAAG,CAAC;EACZ;EACA,IAAId,IAAI;EAER,OAAOd,KAAK;;EAEZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,KAAKA,CAACC,IAAI,EAAE;IACnB7C,MAAM,CAAC6C,IAAI,KAAKxC,KAAK,CAACS,iBAAiB,EAAE,cAAc,CAAC;IACxDa,OAAO,CAAC4B,KAAK,CAAC,uBAAuB,CAAC,CAACyB,UAAU,GAAG,IAAI;IACxDrD,OAAO,CAAC4B,KAAK,CAAC,4BAA4B,CAAC;IAC3C5B,OAAO,CAAC4B,KAAK,CAAC,kCAAkC,CAAC;IACjD5B,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;IACrBlB,OAAO,CAACT,IAAI,CAAC,kCAAkC,CAAC;IAChD,OAAO+D,aAAa;EACtB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,aAAaA,CAACpC,IAAI,EAAE;IAC3B,IAAIA,IAAI,KAAKxC,KAAK,CAAC+C,KAAK,EAAE;MACxBzB,OAAO,CAAC4B,KAAK,CAAC,6BAA6B,CAAC;MAC5C5B,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;MACrBlB,OAAO,CAACT,IAAI,CAAC,6BAA6B,CAAC;MAC3CS,OAAO,CAAC4B,KAAK,CAAC,kCAAkC,CAAC;MACjD5B,OAAO,CAAC4B,KAAK,CAAC,aAAa,CAAC,CAACc,WAAW,GAAG,QAAQ;MACnD,OAAOa,WAAW;IACpB;IAEA,OAAOtD,GAAG,CAACiB,IAAI,CAAC;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASqC,WAAWA,CAACrC,IAAI,EAAE;IACzB;IACE;IACA2B,IAAI,GAAGlE,SAAS,CAACqE,oBAAoB;IACrC;IACC9B,IAAI,KAAKxC,KAAK,CAACiB,kBAAkB,IAAI,CAACoC,IAAK;IAC5C;IACA;IACAb,IAAI,KAAKxC,KAAK,CAACuE,GAAG,IAClB/B,IAAI,KAAKxC,KAAK,CAACS,iBAAiB,IAChCX,yBAAyB,CAAC0C,IAAI,CAAC,EAC/B;MACA,OAAOjB,GAAG,CAACiB,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAKxC,KAAK,CAACiB,kBAAkB,EAAE;MACrCK,OAAO,CAACT,IAAI,CAAC,aAAa,CAAC;MAC3B,MAAMmB,KAAK,GAAGV,OAAO,CAACT,IAAI,CAAC,kCAAkC,CAAC;MAC9D6D,UAAU,GAAG3E,mBAAmB,CAACyB,IAAI,CAACmB,cAAc,CAACX,KAAK,CAAC,CAAC;MAC5DV,OAAO,CAAC4B,KAAK,CAAC,kCAAkC,CAAC;MACjD5B,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;MACrBlB,OAAO,CAACT,IAAI,CAAC,kCAAkC,CAAC;MAChDS,OAAO,CAACT,IAAI,CAAC,4BAA4B,CAAC;MAC1C,OAAOiE,UAAU;IACnB;IAEA,IAAI,CAAChF,yBAAyB,CAAC0C,IAAI,CAAC,EAAE;MACpCa,IAAI,GAAG,IAAI;IACb;IAEAc,IAAI,EAAE;IACN7C,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;IACrB,OAAOA,IAAI,KAAKxC,KAAK,CAACwE,SAAS,GAAGO,WAAW,GAAGF,WAAW;EAC7D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASE,WAAWA,CAACvC,IAAI,EAAE;IACzB,IACEA,IAAI,KAAKxC,KAAK,CAACS,iBAAiB,IAChC+B,IAAI,KAAKxC,KAAK,CAACwE,SAAS,IACxBhC,IAAI,KAAKxC,KAAK,CAACiB,kBAAkB,EACjC;MACAK,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;MACrB2B,IAAI,EAAE;MACN,OAAOU,WAAW;IACpB;IAEA,OAAOA,WAAW,CAACrC,IAAI,CAAC;EAC1B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASsC,UAAUA,CAACtC,IAAI,EAAE;IACxB,IAAIA,IAAI,KAAKxC,KAAK,CAACgF,KAAK,EAAE;MACxB1D,OAAO,CAAC4B,KAAK,CAAC,kBAAkB,CAAC;MACjC5B,OAAO,CAAC6B,OAAO,CAACX,IAAI,CAAC;MACrBlB,OAAO,CAACT,IAAI,CAAC,kBAAkB,CAAC;MAEhC,IAAI,CAACe,OAAO,CAACoB,QAAQ,CAAC0B,UAAU,CAAC,EAAE;QACjC9C,OAAO,CAACqD,IAAI,CAACP,UAAU,CAAC;MAC1B;;MAEA;MACA;MACA;MACA,OAAO7E,YAAY,CACjByB,OAAO,EACP4D,eAAe,EACf,iCACF,CAAC;IACH;IAEA,OAAO3D,GAAG,CAACiB,IAAI,CAAC;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAAS0C,eAAeA,CAAC1C,IAAI,EAAE;IAC7B;IACA,OAAO9C,EAAE,CAAC8C,IAAI,CAAC;EACjB;AACF;;AAEA;AACA;AACA;AACA;AACA,SAAS5B,8BAA8BA,CAACU,OAAO,EAAE5B,EAAE,EAAE6B,GAAG,EAAE;EACxD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,OAAOD,OAAO,CAAC6D,KAAK,CAACvF,SAAS,EAAEF,EAAE,EAAE4B,OAAO,CAAC8D,OAAO,CAACjF,MAAM,EAAET,EAAE,EAAE6B,GAAG,CAAC,CAAC;AACvE;;AAEA;AACA,SAAST,wBAAwBA,CAACQ,OAAO,EAAE;EACzCA,OAAO,CAACT,IAAI,CAAC,uBAAuB,CAAC;AACvC;;AAEA;AACA;AACA;AACA;AACA,SAASR,cAAcA,CAACiB,OAAO,EAAE5B,EAAE,EAAE6B,GAAG,EAAE;EACxC,MAAMC,IAAI,GAAG,IAAI;EAEjB,OAAO3B,YAAY,CACjByB,OAAO,EACP+D,WAAW,EACX,6BAA6B,EAC7BpF,SAAS,CAACqF,OAAO,GAAG,CACtB,CAAC;;EAED;AACF;AACA;EACE,SAASD,WAAWA,CAAC7C,IAAI,EAAE;IACzB,MAAM+C,IAAI,GAAG/D,IAAI,CAACE,MAAM,CAACF,IAAI,CAACE,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC;IAChD,OAAO4D,IAAI,IACTA,IAAI,CAAC,CAAC,CAAC,CAACtD,IAAI,KAAK,6BAA6B,IAC9CsD,IAAI,CAAC,CAAC,CAAC,CAAC5C,cAAc,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC5D,MAAM,KAAK1B,SAAS,CAACqF,OAAO,GAChE5F,EAAE,CAAC8C,IAAI,CAAC,GACRjB,GAAG,CAACiB,IAAI,CAAC;EACf;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}