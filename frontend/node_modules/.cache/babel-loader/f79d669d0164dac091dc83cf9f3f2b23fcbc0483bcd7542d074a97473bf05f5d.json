{"ast":null,"code":"/**\r\n * @typedef {import('mdast').ImageReference} ImageReference\r\n * @typedef {import('mdast').Parents} Parents\r\n * @typedef {import('../types.js').Info} Info\r\n * @typedef {import('../types.js').State} State\r\n */\n\nimageReference.peek = imageReferencePeek;\n\n/**\r\n * @param {ImageReference} node\r\n * @param {Parents | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType;\n  const exit = state.enter('imageReference');\n  let subexit = state.enter('label');\n  const tracker = state.createTracker(info);\n  let value = tracker.move('![');\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  });\n  value += tracker.move(alt + '][');\n  subexit();\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack;\n  state.stack = [];\n  subexit = state.enter('reference');\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  });\n  subexit();\n  state.stack = stack;\n  exit();\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']');\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1);\n  } else {\n    value += tracker.move(']');\n  }\n  return value;\n}\n\n/**\r\n * @returns {string}\r\n */\nfunction imageReferencePeek() {\n  return '!';\n}","map":{"version":3,"names":["imageReference","peek","imageReferencePeek","node","_","state","info","type","referenceType","exit","enter","subexit","tracker","createTracker","value","move","alt","safe","before","after","current","stack","reference","associationId","slice"],"sources":["E:/Documents/2024-1 YBIGTA/React/blog_git/Ybigta-Blog/frontend/node_modules/mdast-util-to-markdown/lib/handle/image-reference.js"],"sourcesContent":["/**\r\n * @typedef {import('mdast').ImageReference} ImageReference\r\n * @typedef {import('mdast').Parents} Parents\r\n * @typedef {import('../types.js').Info} Info\r\n * @typedef {import('../types.js').State} State\r\n */\r\n\r\nimageReference.peek = imageReferencePeek\r\n\r\n/**\r\n * @param {ImageReference} node\r\n * @param {Parents | undefined} _\r\n * @param {State} state\r\n * @param {Info} info\r\n * @returns {string}\r\n */\r\nexport function imageReference(node, _, state, info) {\r\n  const type = node.referenceType\r\n  const exit = state.enter('imageReference')\r\n  let subexit = state.enter('label')\r\n  const tracker = state.createTracker(info)\r\n  let value = tracker.move('![')\r\n  const alt = state.safe(node.alt, {\r\n    before: value,\r\n    after: ']',\r\n    ...tracker.current()\r\n  })\r\n  value += tracker.move(alt + '][')\r\n\r\n  subexit()\r\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\r\n  const stack = state.stack\r\n  state.stack = []\r\n  subexit = state.enter('reference')\r\n  // Note: for proper tracking, we should reset the output positions when we end\r\n  // up making a `shortcut` reference, because then there is no brace output.\r\n  // Practically, in that case, there is no content, so it doesn’t matter that\r\n  // we’ve tracked one too many characters.\r\n  const reference = state.safe(state.associationId(node), {\r\n    before: value,\r\n    after: ']',\r\n    ...tracker.current()\r\n  })\r\n  subexit()\r\n  state.stack = stack\r\n  exit()\r\n\r\n  if (type === 'full' || !alt || alt !== reference) {\r\n    value += tracker.move(reference + ']')\r\n  } else if (type === 'shortcut') {\r\n    // Remove the unwanted `[`.\r\n    value = value.slice(0, -1)\r\n  } else {\r\n    value += tracker.move(']')\r\n  }\r\n\r\n  return value\r\n}\r\n\r\n/**\r\n * @returns {string}\r\n */\r\nfunction imageReferencePeek() {\r\n  return '!'\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEAA,cAAc,CAACC,IAAI,GAAGC,kBAAkB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASF,cAAcA,CAACG,IAAI,EAAEC,CAAC,EAAEC,KAAK,EAAEC,IAAI,EAAE;EACnD,MAAMC,IAAI,GAAGJ,IAAI,CAACK,aAAa;EAC/B,MAAMC,IAAI,GAAGJ,KAAK,CAACK,KAAK,CAAC,gBAAgB,CAAC;EAC1C,IAAIC,OAAO,GAAGN,KAAK,CAACK,KAAK,CAAC,OAAO,CAAC;EAClC,MAAME,OAAO,GAAGP,KAAK,CAACQ,aAAa,CAACP,IAAI,CAAC;EACzC,IAAIQ,KAAK,GAAGF,OAAO,CAACG,IAAI,CAAC,IAAI,CAAC;EAC9B,MAAMC,GAAG,GAAGX,KAAK,CAACY,IAAI,CAACd,IAAI,CAACa,GAAG,EAAE;IAC/BE,MAAM,EAAEJ,KAAK;IACbK,KAAK,EAAE,GAAG;IACV,GAAGP,OAAO,CAACQ,OAAO,CAAC;EACrB,CAAC,CAAC;EACFN,KAAK,IAAIF,OAAO,CAACG,IAAI,CAACC,GAAG,GAAG,IAAI,CAAC;EAEjCL,OAAO,CAAC,CAAC;EACT;EACA,MAAMU,KAAK,GAAGhB,KAAK,CAACgB,KAAK;EACzBhB,KAAK,CAACgB,KAAK,GAAG,EAAE;EAChBV,OAAO,GAAGN,KAAK,CAACK,KAAK,CAAC,WAAW,CAAC;EAClC;EACA;EACA;EACA;EACA,MAAMY,SAAS,GAAGjB,KAAK,CAACY,IAAI,CAACZ,KAAK,CAACkB,aAAa,CAACpB,IAAI,CAAC,EAAE;IACtDe,MAAM,EAAEJ,KAAK;IACbK,KAAK,EAAE,GAAG;IACV,GAAGP,OAAO,CAACQ,OAAO,CAAC;EACrB,CAAC,CAAC;EACFT,OAAO,CAAC,CAAC;EACTN,KAAK,CAACgB,KAAK,GAAGA,KAAK;EACnBZ,IAAI,CAAC,CAAC;EAEN,IAAIF,IAAI,KAAK,MAAM,IAAI,CAACS,GAAG,IAAIA,GAAG,KAAKM,SAAS,EAAE;IAChDR,KAAK,IAAIF,OAAO,CAACG,IAAI,CAACO,SAAS,GAAG,GAAG,CAAC;EACxC,CAAC,MAAM,IAAIf,IAAI,KAAK,UAAU,EAAE;IAC9B;IACAO,KAAK,GAAGA,KAAK,CAACU,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAC5B,CAAC,MAAM;IACLV,KAAK,IAAIF,OAAO,CAACG,IAAI,CAAC,GAAG,CAAC;EAC5B;EAEA,OAAOD,KAAK;AACd;;AAEA;AACA;AACA;AACA,SAASZ,kBAAkBA,CAAA,EAAG;EAC5B,OAAO,GAAG;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}