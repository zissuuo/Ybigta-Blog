{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\r\n */\n\n/**\r\n * @typedef {import('./infer.js').Align} Align\r\n */\n\nimport { ok as assert } from 'devlop';\nconst alignment = {\n  none: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n};\n\n// To do: micromark@5: use `infer` here, when all events are exposed.\n\n/**\r\n * Create an HTML extension for `micromark` to support GitHub tables when\r\n * serializing to HTML.\r\n *\r\n * @returns {HtmlExtension}\r\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\r\n *   support GitHub tables when serializing to HTML.\r\n */\nexport function gfmTableHtml() {\n  return {\n    enter: {\n      table(token) {\n        const tableAlign = token._align;\n        assert(tableAlign, 'expected `_align`');\n        this.lineEndingIfNeeded();\n        this.tag('<table>');\n        this.setData('tableAlign', tableAlign);\n      },\n      tableBody() {\n        this.tag('<tbody>');\n      },\n      tableData() {\n        const tableAlign = this.getData('tableAlign');\n        const tableColumn = this.getData('tableColumn');\n        assert(tableAlign, 'expected `tableAlign`');\n        assert(typeof tableColumn === 'number', 'expected `tableColumn`');\n        const align = alignment[tableAlign[tableColumn]];\n        if (align === undefined) {\n          // Capture results to ignore them.\n          this.buffer();\n        } else {\n          this.lineEndingIfNeeded();\n          this.tag('<td' + align + '>');\n        }\n      },\n      tableHead() {\n        this.lineEndingIfNeeded();\n        this.tag('<thead>');\n      },\n      tableHeader() {\n        const tableAlign = this.getData('tableAlign');\n        const tableColumn = this.getData('tableColumn');\n        assert(tableAlign, 'expected `tableAlign`');\n        assert(typeof tableColumn === 'number', 'expected `tableColumn`');\n        const align = alignment[tableAlign[tableColumn]];\n        this.lineEndingIfNeeded();\n        this.tag('<th' + align + '>');\n      },\n      tableRow() {\n        this.setData('tableColumn', 0);\n        this.lineEndingIfNeeded();\n        this.tag('<tr>');\n      }\n    },\n    exit: {\n      // Overwrite the default code text data handler to unescape escaped pipes when\n      // they are in tables.\n      codeTextData(token) {\n        let value = this.sliceSerialize(token);\n        if (this.getData('tableAlign')) {\n          value = value.replace(/\\\\([\\\\|])/g, replace);\n        }\n        this.raw(this.encode(value));\n      },\n      table() {\n        this.setData('tableAlign');\n        // Note: we don’t set `slurpAllLineEndings` anymore, in delimiter rows,\n        // but we do need to reset it to match a funky newline GH generates for\n        // list items combined with tables.\n        this.setData('slurpAllLineEndings');\n        this.lineEndingIfNeeded();\n        this.tag('</table>');\n      },\n      tableBody() {\n        this.lineEndingIfNeeded();\n        this.tag('</tbody>');\n      },\n      tableData() {\n        const tableAlign = this.getData('tableAlign');\n        const tableColumn = this.getData('tableColumn');\n        assert(tableAlign, 'expected `tableAlign`');\n        assert(typeof tableColumn === 'number', 'expected `tableColumn`');\n        if (tableColumn in tableAlign) {\n          this.tag('</td>');\n          this.setData('tableColumn', tableColumn + 1);\n        } else {\n          // Stop capturing.\n          this.resume();\n        }\n      },\n      tableHead() {\n        this.lineEndingIfNeeded();\n        this.tag('</thead>');\n      },\n      tableHeader() {\n        const tableColumn = this.getData('tableColumn');\n        assert(typeof tableColumn === 'number', 'expected `tableColumn`');\n        this.tag('</th>');\n        this.setData('tableColumn', tableColumn + 1);\n      },\n      tableRow() {\n        const tableAlign = this.getData('tableAlign');\n        let tableColumn = this.getData('tableColumn');\n        assert(tableAlign, 'expected `tableAlign`');\n        assert(typeof tableColumn === 'number', 'expected `tableColumn`');\n        while (tableColumn < tableAlign.length) {\n          this.lineEndingIfNeeded();\n          this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>');\n          tableColumn++;\n        }\n        this.setData('tableColumn', tableColumn);\n        this.lineEndingIfNeeded();\n        this.tag('</tr>');\n      }\n    }\n  };\n}\n\n/**\r\n * @param {string} $0\r\n * @param {string} $1\r\n * @returns {string}\r\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0;\n}","map":{"version":3,"names":["ok","assert","alignment","none","left","right","center","gfmTableHtml","enter","table","token","tableAlign","_align","lineEndingIfNeeded","tag","setData","tableBody","tableData","getData","tableColumn","align","undefined","buffer","tableHead","tableHeader","tableRow","exit","codeTextData","value","sliceSerialize","replace","raw","encode","resume","length","$0","$1"],"sources":["E:/Documents/2024-1 YBIGTA/Ybigta_BLOG/blog_git/Ybigta-Blog/frontend/node_modules/micromark-extension-gfm-table/dev/lib/html.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\r\n */\r\n\r\n/**\r\n * @typedef {import('./infer.js').Align} Align\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\n\r\nconst alignment = {\r\n  none: '',\r\n  left: ' align=\"left\"',\r\n  right: ' align=\"right\"',\r\n  center: ' align=\"center\"'\r\n}\r\n\r\n// To do: micromark@5: use `infer` here, when all events are exposed.\r\n\r\n/**\r\n * Create an HTML extension for `micromark` to support GitHub tables when\r\n * serializing to HTML.\r\n *\r\n * @returns {HtmlExtension}\r\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\r\n *   support GitHub tables when serializing to HTML.\r\n */\r\nexport function gfmTableHtml() {\r\n  return {\r\n    enter: {\r\n      table(token) {\r\n        const tableAlign = token._align\r\n        assert(tableAlign, 'expected `_align`')\r\n        this.lineEndingIfNeeded()\r\n        this.tag('<table>')\r\n        this.setData('tableAlign', tableAlign)\r\n      },\r\n      tableBody() {\r\n        this.tag('<tbody>')\r\n      },\r\n      tableData() {\r\n        const tableAlign = this.getData('tableAlign')\r\n        const tableColumn = this.getData('tableColumn')\r\n        assert(tableAlign, 'expected `tableAlign`')\r\n        assert(typeof tableColumn === 'number', 'expected `tableColumn`')\r\n        const align = alignment[tableAlign[tableColumn]]\r\n\r\n        if (align === undefined) {\r\n          // Capture results to ignore them.\r\n          this.buffer()\r\n        } else {\r\n          this.lineEndingIfNeeded()\r\n          this.tag('<td' + align + '>')\r\n        }\r\n      },\r\n      tableHead() {\r\n        this.lineEndingIfNeeded()\r\n        this.tag('<thead>')\r\n      },\r\n      tableHeader() {\r\n        const tableAlign = this.getData('tableAlign')\r\n        const tableColumn = this.getData('tableColumn')\r\n        assert(tableAlign, 'expected `tableAlign`')\r\n        assert(typeof tableColumn === 'number', 'expected `tableColumn`')\r\n        const align = alignment[tableAlign[tableColumn]]\r\n        this.lineEndingIfNeeded()\r\n        this.tag('<th' + align + '>')\r\n      },\r\n      tableRow() {\r\n        this.setData('tableColumn', 0)\r\n        this.lineEndingIfNeeded()\r\n        this.tag('<tr>')\r\n      }\r\n    },\r\n    exit: {\r\n      // Overwrite the default code text data handler to unescape escaped pipes when\r\n      // they are in tables.\r\n      codeTextData(token) {\r\n        let value = this.sliceSerialize(token)\r\n\r\n        if (this.getData('tableAlign')) {\r\n          value = value.replace(/\\\\([\\\\|])/g, replace)\r\n        }\r\n\r\n        this.raw(this.encode(value))\r\n      },\r\n      table() {\r\n        this.setData('tableAlign')\r\n        // Note: we don’t set `slurpAllLineEndings` anymore, in delimiter rows,\r\n        // but we do need to reset it to match a funky newline GH generates for\r\n        // list items combined with tables.\r\n        this.setData('slurpAllLineEndings')\r\n        this.lineEndingIfNeeded()\r\n        this.tag('</table>')\r\n      },\r\n      tableBody() {\r\n        this.lineEndingIfNeeded()\r\n        this.tag('</tbody>')\r\n      },\r\n      tableData() {\r\n        const tableAlign = this.getData('tableAlign')\r\n        const tableColumn = this.getData('tableColumn')\r\n        assert(tableAlign, 'expected `tableAlign`')\r\n        assert(typeof tableColumn === 'number', 'expected `tableColumn`')\r\n\r\n        if (tableColumn in tableAlign) {\r\n          this.tag('</td>')\r\n          this.setData('tableColumn', tableColumn + 1)\r\n        } else {\r\n          // Stop capturing.\r\n          this.resume()\r\n        }\r\n      },\r\n      tableHead() {\r\n        this.lineEndingIfNeeded()\r\n        this.tag('</thead>')\r\n      },\r\n      tableHeader() {\r\n        const tableColumn = this.getData('tableColumn')\r\n        assert(typeof tableColumn === 'number', 'expected `tableColumn`')\r\n        this.tag('</th>')\r\n        this.setData('tableColumn', tableColumn + 1)\r\n      },\r\n      tableRow() {\r\n        const tableAlign = this.getData('tableAlign')\r\n        let tableColumn = this.getData('tableColumn')\r\n        assert(tableAlign, 'expected `tableAlign`')\r\n        assert(typeof tableColumn === 'number', 'expected `tableColumn`')\r\n\r\n        while (tableColumn < tableAlign.length) {\r\n          this.lineEndingIfNeeded()\r\n          this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>')\r\n          tableColumn++\r\n        }\r\n\r\n        this.setData('tableColumn', tableColumn)\r\n        this.lineEndingIfNeeded()\r\n        this.tag('</tr>')\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} $0\r\n * @param {string} $1\r\n * @returns {string}\r\n */\r\nfunction replace($0, $1) {\r\n  // Pipes work, backslashes don’t (but can’t escape pipes).\r\n  return $1 === '|' ? $1 : $0\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}