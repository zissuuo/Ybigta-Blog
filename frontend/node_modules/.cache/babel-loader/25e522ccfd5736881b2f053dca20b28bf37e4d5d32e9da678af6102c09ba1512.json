{"ast":null,"code":"/**\r\n * @typedef {import('mdast').ListItem} ListItem\r\n * @typedef {import('mdast').Paragraph} Paragraph\r\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\r\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\r\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\r\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\r\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\r\n */\n\nimport { ok as assert } from 'devlop';\nimport { defaultHandlers } from 'mdast-util-to-markdown';\n\n/**\r\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\r\n * list items in markdown.\r\n *\r\n * @returns {FromMarkdownExtension}\r\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\r\n */\nexport function gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  };\n}\n\n/**\r\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\r\n * items in markdown.\r\n *\r\n * @returns {ToMarkdownExtension}\r\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\r\n */\nexport function gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{\n      atBreak: true,\n      character: '-',\n      after: '[:|-]'\n    }],\n    handlers: {\n      listItem: listItemWithTaskListItem\n    }\n  };\n}\n\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\nfunction exitCheck(token) {\n  // We’re always in a paragraph, in a list item.\n  const node = this.stack[this.stack.length - 2];\n  assert(node.type === 'listItem');\n  node.checked = token.type === 'taskListCheckValueChecked';\n}\n\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2];\n  if (parent && parent.type === 'listItem' && typeof parent.checked === 'boolean') {\n    const node = this.stack[this.stack.length - 1];\n    assert(node.type === 'paragraph');\n    const head = node.children[0];\n    if (head && head.type === 'text') {\n      const siblings = parent.children;\n      let index = -1;\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph;\n      while (++index < siblings.length) {\n        const sibling = siblings[index];\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling;\n          break;\n        }\n      }\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1);\n        if (head.value.length === 0) {\n          node.children.shift();\n        } else if (node.position && head.position && typeof head.position.start.offset === 'number') {\n          head.position.start.column++;\n          head.position.start.offset++;\n          node.position.start = Object.assign({}, head.position.start);\n        }\n      }\n    }\n  }\n  this.exit(token);\n}\n\n/**\r\n * @type {ToMarkdownHandle}\r\n * @param {ListItem} node\r\n */\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0];\n  const checkable = typeof node.checked === 'boolean' && head && head.type === 'paragraph';\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] ';\n  const tracker = state.createTracker(info);\n  if (checkable) {\n    tracker.move(checkbox);\n  }\n  let value = defaultHandlers.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  });\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check);\n  }\n  return value;\n\n  /**\r\n   * @param {string} $0\r\n   * @returns {string}\r\n   */\n  function check($0) {\n    return $0 + checkbox;\n  }\n}","map":{"version":3,"names":["ok","assert","defaultHandlers","gfmTaskListItemFromMarkdown","exit","taskListCheckValueChecked","exitCheck","taskListCheckValueUnchecked","paragraph","exitParagraphWithTaskListItem","gfmTaskListItemToMarkdown","unsafe","atBreak","character","after","handlers","listItem","listItemWithTaskListItem","token","node","stack","length","type","checked","parent","head","children","siblings","index","firstParaghraph","sibling","value","slice","shift","position","start","offset","column","Object","assign","state","info","checkable","checkbox","tracker","createTracker","move","current","replace","check","$0"],"sources":["E:/Documents/2024-1 YBIGTA/Ybigta_BLOG/blog_git/Ybigta-Blog/frontend/node_modules/mdast-util-gfm-task-list-item/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('mdast').ListItem} ListItem\r\n * @typedef {import('mdast').Paragraph} Paragraph\r\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\r\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\r\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\r\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\r\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {defaultHandlers} from 'mdast-util-to-markdown'\r\n\r\n/**\r\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\r\n * list items in markdown.\r\n *\r\n * @returns {FromMarkdownExtension}\r\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\r\n */\r\nexport function gfmTaskListItemFromMarkdown() {\r\n  return {\r\n    exit: {\r\n      taskListCheckValueChecked: exitCheck,\r\n      taskListCheckValueUnchecked: exitCheck,\r\n      paragraph: exitParagraphWithTaskListItem\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\r\n * items in markdown.\r\n *\r\n * @returns {ToMarkdownExtension}\r\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\r\n */\r\nexport function gfmTaskListItemToMarkdown() {\r\n  return {\r\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\r\n    handlers: {listItem: listItemWithTaskListItem}\r\n  }\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitCheck(token) {\r\n  // We’re always in a paragraph, in a list item.\r\n  const node = this.stack[this.stack.length - 2]\r\n  assert(node.type === 'listItem')\r\n  node.checked = token.type === 'taskListCheckValueChecked'\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitParagraphWithTaskListItem(token) {\r\n  const parent = this.stack[this.stack.length - 2]\r\n\r\n  if (\r\n    parent &&\r\n    parent.type === 'listItem' &&\r\n    typeof parent.checked === 'boolean'\r\n  ) {\r\n    const node = this.stack[this.stack.length - 1]\r\n    assert(node.type === 'paragraph')\r\n    const head = node.children[0]\r\n\r\n    if (head && head.type === 'text') {\r\n      const siblings = parent.children\r\n      let index = -1\r\n      /** @type {Paragraph | undefined} */\r\n      let firstParaghraph\r\n\r\n      while (++index < siblings.length) {\r\n        const sibling = siblings[index]\r\n        if (sibling.type === 'paragraph') {\r\n          firstParaghraph = sibling\r\n          break\r\n        }\r\n      }\r\n\r\n      if (firstParaghraph === node) {\r\n        // Must start with a space or a tab.\r\n        head.value = head.value.slice(1)\r\n\r\n        if (head.value.length === 0) {\r\n          node.children.shift()\r\n        } else if (\r\n          node.position &&\r\n          head.position &&\r\n          typeof head.position.start.offset === 'number'\r\n        ) {\r\n          head.position.start.column++\r\n          head.position.start.offset++\r\n          node.position.start = Object.assign({}, head.position.start)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  this.exit(token)\r\n}\r\n\r\n/**\r\n * @type {ToMarkdownHandle}\r\n * @param {ListItem} node\r\n */\r\nfunction listItemWithTaskListItem(node, parent, state, info) {\r\n  const head = node.children[0]\r\n  const checkable =\r\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\r\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\r\n  const tracker = state.createTracker(info)\r\n\r\n  if (checkable) {\r\n    tracker.move(checkbox)\r\n  }\r\n\r\n  let value = defaultHandlers.listItem(node, parent, state, {\r\n    ...info,\r\n    ...tracker.current()\r\n  })\r\n\r\n  if (checkable) {\r\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\r\n  }\r\n\r\n  return value\r\n\r\n  /**\r\n   * @param {string} $0\r\n   * @returns {string}\r\n   */\r\n  function check($0) {\r\n    return $0 + checkbox\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,EAAE,IAAIC,MAAM,QAAO,QAAQ;AACnC,SAAQC,eAAe,QAAO,wBAAwB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,2BAA2BA,CAAA,EAAG;EAC5C,OAAO;IACLC,IAAI,EAAE;MACJC,yBAAyB,EAAEC,SAAS;MACpCC,2BAA2B,EAAED,SAAS;MACtCE,SAAS,EAAEC;IACb;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,yBAAyBA,CAAA,EAAG;EAC1C,OAAO;IACLC,MAAM,EAAE,CAAC;MAACC,OAAO,EAAE,IAAI;MAAEC,SAAS,EAAE,GAAG;MAAEC,KAAK,EAAE;IAAO,CAAC,CAAC;IACzDC,QAAQ,EAAE;MAACC,QAAQ,EAAEC;IAAwB;EAC/C,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA,SAASX,SAASA,CAACY,KAAK,EAAE;EACxB;EACA,MAAMC,IAAI,GAAG,IAAI,CAACC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC;EAC9CpB,MAAM,CAACkB,IAAI,CAACG,IAAI,KAAK,UAAU,CAAC;EAChCH,IAAI,CAACI,OAAO,GAAGL,KAAK,CAACI,IAAI,KAAK,2BAA2B;AAC3D;;AAEA;AACA;AACA;AACA;AACA,SAASb,6BAA6BA,CAACS,KAAK,EAAE;EAC5C,MAAMM,MAAM,GAAG,IAAI,CAACJ,KAAK,CAAC,IAAI,CAACA,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC;EAEhD,IACEG,MAAM,IACNA,MAAM,CAACF,IAAI,KAAK,UAAU,IAC1B,OAAOE,MAAM,CAACD,OAAO,KAAK,SAAS,EACnC;IACA,MAAMJ,IAAI,GAAG,IAAI,CAACC,KAAK,CAAC,IAAI,CAACA,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC;IAC9CpB,MAAM,CAACkB,IAAI,CAACG,IAAI,KAAK,WAAW,CAAC;IACjC,MAAMG,IAAI,GAAGN,IAAI,CAACO,QAAQ,CAAC,CAAC,CAAC;IAE7B,IAAID,IAAI,IAAIA,IAAI,CAACH,IAAI,KAAK,MAAM,EAAE;MAChC,MAAMK,QAAQ,GAAGH,MAAM,CAACE,QAAQ;MAChC,IAAIE,KAAK,GAAG,CAAC,CAAC;MACd;MACA,IAAIC,eAAe;MAEnB,OAAO,EAAED,KAAK,GAAGD,QAAQ,CAACN,MAAM,EAAE;QAChC,MAAMS,OAAO,GAAGH,QAAQ,CAACC,KAAK,CAAC;QAC/B,IAAIE,OAAO,CAACR,IAAI,KAAK,WAAW,EAAE;UAChCO,eAAe,GAAGC,OAAO;UACzB;QACF;MACF;MAEA,IAAID,eAAe,KAAKV,IAAI,EAAE;QAC5B;QACAM,IAAI,CAACM,KAAK,GAAGN,IAAI,CAACM,KAAK,CAACC,KAAK,CAAC,CAAC,CAAC;QAEhC,IAAIP,IAAI,CAACM,KAAK,CAACV,MAAM,KAAK,CAAC,EAAE;UAC3BF,IAAI,CAACO,QAAQ,CAACO,KAAK,CAAC,CAAC;QACvB,CAAC,MAAM,IACLd,IAAI,CAACe,QAAQ,IACbT,IAAI,CAACS,QAAQ,IACb,OAAOT,IAAI,CAACS,QAAQ,CAACC,KAAK,CAACC,MAAM,KAAK,QAAQ,EAC9C;UACAX,IAAI,CAACS,QAAQ,CAACC,KAAK,CAACE,MAAM,EAAE;UAC5BZ,IAAI,CAACS,QAAQ,CAACC,KAAK,CAACC,MAAM,EAAE;UAC5BjB,IAAI,CAACe,QAAQ,CAACC,KAAK,GAAGG,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEd,IAAI,CAACS,QAAQ,CAACC,KAAK,CAAC;QAC9D;MACF;IACF;EACF;EAEA,IAAI,CAAC/B,IAAI,CAACc,KAAK,CAAC;AAClB;;AAEA;AACA;AACA;AACA;AACA,SAASD,wBAAwBA,CAACE,IAAI,EAAEK,MAAM,EAAEgB,KAAK,EAAEC,IAAI,EAAE;EAC3D,MAAMhB,IAAI,GAAGN,IAAI,CAACO,QAAQ,CAAC,CAAC,CAAC;EAC7B,MAAMgB,SAAS,GACb,OAAOvB,IAAI,CAACI,OAAO,KAAK,SAAS,IAAIE,IAAI,IAAIA,IAAI,CAACH,IAAI,KAAK,WAAW;EACxE,MAAMqB,QAAQ,GAAG,GAAG,IAAIxB,IAAI,CAACI,OAAO,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG,IAAI;EACxD,MAAMqB,OAAO,GAAGJ,KAAK,CAACK,aAAa,CAACJ,IAAI,CAAC;EAEzC,IAAIC,SAAS,EAAE;IACbE,OAAO,CAACE,IAAI,CAACH,QAAQ,CAAC;EACxB;EAEA,IAAIZ,KAAK,GAAG7B,eAAe,CAACc,QAAQ,CAACG,IAAI,EAAEK,MAAM,EAAEgB,KAAK,EAAE;IACxD,GAAGC,IAAI;IACP,GAAGG,OAAO,CAACG,OAAO,CAAC;EACrB,CAAC,CAAC;EAEF,IAAIL,SAAS,EAAE;IACbX,KAAK,GAAGA,KAAK,CAACiB,OAAO,CAAC,iCAAiC,EAAEC,KAAK,CAAC;EACjE;EAEA,OAAOlB,KAAK;;EAEZ;AACF;AACA;AACA;EACE,SAASkB,KAAKA,CAACC,EAAE,EAAE;IACjB,OAAOA,EAAE,GAAGP,QAAQ;EACtB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}